<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F07%2F18%2F%E8%87%AA%E6%88%91%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[一.原生Js基础 掌握情况——非常重要基本数据类型和引用数据类型的区别 js 分为两种数据类型： 基本数据类型：Number、String、Boolean、Null、 Undefined、Symbol（ES6），这些类型可以直接操作保存在变量中的实际值。 引用数据类型：Object （ 在 js 中除了基本数据类型以外都是对象，数据是对象，函数时对象，正则表达式是对象） 栈(stack)和堆（heap） 栈（stack）为自动分配的空间，它由系统自动释放，先进后出。 堆（heap）则是动态分配的内存，大小也不一定会自动释放，队列优先，先进先出。 基本数据类型（存放在栈中） 基本数据类型是指存放在栈中的简单数据段，数据大小确定，内存空间可以分配，它们是直接按值存放的，所以可以按值直接访问 引用数据类型（存放在堆内存中的对象，每个空间大小不一样，要根据情况进行特定的配置） 引用类型是存放在堆内存中的对象，变量其实是保存的在栈内存中的一个指针（保存的是堆内存中的引用地址），这个指针指向堆内存 引用类型数据在栈内存中保存的实际上是对象在堆内存中的引用地址，通过这个地址可以快速查找到保存在堆内存中的对象 从一个向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终指向同一个对象。即复制的是栈中的地址而不是堆中的对象 深拷贝和浅拷贝简单解释 浅拷贝和深拷贝都只针对于引用数据类型 浅拷贝只复制指向某个对象的指针，而不是复制对象本身，新旧对象共享同一块内存 深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象 深拷贝和浅拷贝的区别 浅拷贝值复制对象的第一层属性，深拷贝可以对对象的属性进行递归复制 js 深拷贝 手动实现深拷贝 1234567891011let obj1 = &#123; a: 1, b: 2&#125;let obj2 = &#123; a: obj1.a, b: obj1.b&#125;obj2.a = 3;alert(obj1.a); // 1alert(obj2.a); // 3 1234567891011let obj1 = &#123; a: &#123; b: 2 &#125;&#125;let obj2 = &#123; a: obj1.a&#125;obj2.a.b = 3;console.log(obj1.a.b); // 3console.log(obj2.a.b); // 3 递归实现深拷贝 12345678910111213141516171819202122232425262728293031function deepCopy(obj1) &#123; var obj2 = Array.isArray(obj1) ? [] : &#123;&#125;; if (obj1 &amp;&amp; typeof obj1 === "object") &#123; for (var i in obj1) &#123; if (obj1.hasOwnProperty(i)) &#123; // 如果子属性为引用数据类型，递归复制 if (obj1[i] &amp;&amp; typeof obj1[i] === "object") &#123; obj2[i] = deepCopy(obj1[i]); &#125; else &#123; // 如果是基本数据类型，只是简单的复制 obj2[i] = obj1[i]; &#125; &#125; &#125; &#125; return obj2; &#125; var obj1 = &#123; a: 1, b: 2, c: &#123; d: 3 &#125; &#125; var obj2 = deepCopy(obj1); obj2.a = 3; obj2.c.d = 4; alert(obj1.a); // 1 alert(obj2.a); // 3 alert(obj1.c.d); // 3 alert(obj2.c.d); // 4 缺陷：当遇到互相引用的对象，会出现死循环的情况，为了避免相互引用的对象导致死循环的情况，则应该在遍历的时候判断是否相互引用对象，如果是则退出循环 123456789101112131415161718192021222324252627282930313233343536function deepCopy(obj1) &#123; var obj2 = Array.isArray(obj1) ? [] : &#123;&#125;; if (obj1 &amp;&amp; typeof obj1 === "object") &#123; for (var i in obj1) &#123; var prop = obj1[i]; // 避免相互引用造成死循环，如obj1.a=obj if (prop == obj1) &#123; continue; &#125; if (obj1.hasOwnProperty(i)) &#123; // 如果子属性为引用数据类型，递归复制 if (prop &amp;&amp; typeof prop === "object") &#123; obj2[i] = (prop.constructor === Array) ? [] : &#123;&#125;; arguments.callee(prop, obj2[i]); // 递归调用 &#125; else &#123; // 如果是基本数据类型，只是简单的复制 obj2[i] = prop; &#125; &#125; &#125; &#125; return obj2; &#125; var obj1 = &#123; a: 1, b: 2, c: &#123; d: 3 &#125; &#125; var obj2 = deepCopy(obj1); obj2.a = 3; obj2.c.d = 4; alert(obj1.a); // 1 alert(obj2.a); // 3 alert(obj1.c.d); // 3 alert(obj2.c.d); // 4 使用 JSON.stringify 和 JSON.parse 实现深拷贝：JSON.stringify 把对象转成字符串，再用JSON.parse 把字符串转成新的对象 12345678910function deepCopy(obj1)&#123; let _obj = JSON.stringify(obj1); let obj2 = JSON.parse(_obj); return obj2; &#125; var a = [1, [1, 2], 3, 4]; var b = deepCopy(a); b[1][0] = 2; alert(a); // 1,1,2,3,4 alert(b); // 2,2,2,3,4 它会抛弃对象的 constructor ，深拷贝之后，不管这个对象原来的构造函数时什么，在深拷贝之后都会变成 Object ；这种方法能正确处理的对象只有 Number，String，Boolean，Array，扁平对象，也就是说，只有可以转成 JSON 格式的对象才可以这样用。像 function 没办法转成 JSON。 12345678let obj1 = &#123; fun:function()&#123; alert(123); &#125; &#125; let obj2 = JSON.parse(JSON.stringify(obj1)); console.log(typeof obj1.fun); // function console.log(typeof obj2.fun); // undefined 热门的函数库 lodash ，也有提供 _.cloneDeep 用来做深拷贝； 123456789var _ = require('lodash'); var obj1 = &#123; a: 1, b: &#123; f: &#123; g: 1 &#125; &#125;, c: [1, 2, 3] &#125;; var obj2 = _.cloneDeep(obj1); console.log(obj1.b.f === obj2.b.f); // false jquery 实现深拷贝，jquery提供一个 $.extend可以用来做深拷贝 123456789101112var $ = require('jquery'); var obj1 = &#123; a: 1, b: &#123; f: &#123; g: 1 &#125; &#125;, c: [1, 2, 3] &#125;; var obj2 = $.extend(true, &#123;&#125;, obj1); console.log(obj1.b.f === obj2.b.f); // false slice()和concat()都并非深拷贝 123456// 对只有一级属性值的数组对象使用slice var a = [1,2,3,4]; var b = a.slice(); b[0] = 2; alert(a); // 1,2,3,4 alert(b); // 2,2,3,4 123456// 对有多层属性的数组对象使用slice var a = [1,[1,2],3,4]; var b = a.slice(); b[1][0] = 2; alert(a); // 1,2,2,3,4 alert(b); // 1,2,2,3,4 参考资料：https://www.jianshu.com/p/cf1e9d7e94fb及https://www.cnblogs.com/echolun/p/7889848.html 实现继承的几种方式及工作原理js 继承的实现方式 既然要实现继承，首先定义一个父类 12345678910111213// 定义一个动物类function Animal (name) &#123; // 属性 this.name = name || 'Animal'; // 实例方法 this.sleep = function()&#123; console.log(this.name + '正在睡觉！'); &#125;&#125;// 原型方法Animal.prototype.eat = function(food) &#123; console.log(this.name + '正在吃：' + food);&#125;; 原型链继承 核心：将父类的实例作为子类的原型 123456789101112function Cat()&#123; &#125;Cat.prototype = new Animal();Cat.prototype.name = 'cat';// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.eat('fish'));console.log(cat.sleep());console.log(cat instanceof Animal); //true console.log(cat instanceof Cat); //true 特点： 非常纯粹的继承关系，实例是子类的实例，也是父类的实例。 父类新增原型方法/原型属性，子类都能访问到。 简单，易于实现。 缺点： 要想为子类新增属性和方法，必须要在new Animal()这样的语句之后执行，不能放到构造器中。 无法实现多继承。 来自原型对象的所有属性被所有实例共享 创建子类实例时，无法向构造函数传参 构造继承 核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型） 1234567891011function Cat(name)&#123; Animal.call(this); this.name = name || 'Tom';&#125;// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // falseconsole.log(cat instanceof Cat); // true 特点： 解决了子类无法共享父类引用属性的问题 创建子类实例时，可以向父类传递参数 可以实现多继承（call 多个父类对象） 缺点： 实例并不是父类的实例，只是子类的实例 只能继承父类的实例属性和方法，不能继承原型属性/方法 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能 实例继承 核心：为父类实例添加新特性，作为子类实例返回 123456789101112function Cat(name)&#123; var instance = new Animal(); instance.name = name || 'Tom'; return instance;&#125;// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); // false 特点： 不限制调用方式，不管是new 子类()还是子类()返回的对象具有相同的效果 缺点： 实例时父类的实例，不是子类的实例 不支持多继承 拷贝继承 1234567891011121314function Cat(name)&#123; var animal = new Animal(); for(var p in animal)&#123; Cat.prototype[p] = animal[p]; &#125; Cat.prototype.name = name || 'Tom';&#125;// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // falseconsole.log(cat instanceof Cat); // true 特点： 支持多继承 缺点： 效率较低，内存占用高（因为要拷贝父类的属性） 无法获取父类不可枚举的方法（不可枚举方法，补课使用 for in 访问到） 组合继承 核心：通过调用父类函数构造，继承弗雷德属性并保留传参的有点，然后通过将父类实例作为子类原型，实现函数复用 12345678910111213141516function Cat(name)&#123; Animal.call(this); this.name = name || 'Tom';&#125;Cat.prototype = new Animal();//组合继承需要修复构造函数指向的。Cat.prototype.constructor = Cat;// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); // true 特点： 可以继承实例属性/方法，也可以继承原型属性/方法 即是子类实例，也是父类实例 不存在引用属性共享问题 可以传参 函数可复用 缺点： 调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了） 寄生组合继承 核心：通过寄生方式，砍掉父亲的实例属性，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免了组合继承的缺点 12345678910111213141516171819function Cat(name)&#123; Animal.call(this); this.name = name || 'Tom';&#125;(function()&#123; // 创建一个没有实例方法的类 var Super = function()&#123;&#125;; Super.prototype = Animal.prototype; //将实例作为子类的原型 Cat.prototype = new Super();&#125;)();// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); //trueCat.prototype.constructor = Cat; // 需要修复下构造函数 特点： 堪称完美 缺点： 实现较为复杂 参考资料：https://www.cnblogs.com/humin/p/4556820.html 闭包的理解闭包指的是：能够访问另一个函数作用域的变量的函数。清晰的讲：闭包就是一个函数，这个函数能够访问其他函数的作用域中的变量。 闭包的特性： 函数嵌套函数 函数内部可以引用函数外部的参数和变量 参数和变量不会被垃圾回收机制回收 闭包的好处： 保护函数内的变量安全，实现封装，防止变量流入其他环境发生命名冲突。 在内存中维持一个变量，可以做缓存（但使用多了同时也是一项缺点，消耗内存）。 匿名自执行函数可以减少内存消耗。 闭包的坏处： 被引用的私有变量不能被销毁，增大了内存消耗，造成内存泄露，解决方法是可以在使用完变量后手动为它赋值为 null 。 由于闭包涉及跨域访问，所以会导致性能损失，我们可以通过把跨作用域变量存储在局部变量中，然后直接访问局部变量，来减轻对执行速度的影响。 参考资料：https://blog.csdn.net/dovlie/article/details/76339244 及 https://www.jianshu.com/p/26c81fde22fb 预解析和变量提升 预解析： 当 JavaScript 引擎解析脚本时，它会在预编译对所有声明的变量和函数进行处理！ 把变量的声明提前—-提前到当前所在的作用域的最上面 函数的声明也会被提前—-提前到当前作用域的最上面 预解析注意事项： 预解析中，变量的提升，只会在当前的作用域中提升，提前到当前作用域的最上面 函数的变量只会提前到函数的作用域的最前面，不会出去 预解析会分段（多对的 Script 标签中函数重名，预解析的时候不会冲突） 变量提升： 变量提升的只是定义，赋值不会被提升，函数提升也是提升定义，赋值不会提升 函数名字和变量的名字一样也会被覆盖，函数优先级高 如果是通过 var 函数名 = function(){} 定义函数，赋值部分的匿名函数不会被提升 var 、 let 与 const var 声明的变量会挂载在 window 上，而 let 与 const 声明的变量不会。 var 声明变量存在变量提升， let 和 const 不存在变量提升。 let 和 const 声明形成块级作用域。 同一作用域下 let 和 const 不能声明同名变量，而 var 可以。 在当前块级作用域中使用 let / const 声明的情况下，赋值要在声明之后，否则会暂时性死区。 const一旦声明必须赋值，不能使用 null 占位 ，声明后不能修改，如果声明的是复合类型的数据，可以修改其属性。 this 的理解 this 是在函数运行时，自动生成的一个内部对象，只能在函数内部使用 this 指的是直接调用当前方法（函数）的那个对象，也就是说函数在谁那被调用，this 就指向谁 当函数里嵌套函数的时候，嵌套的那个函数的里面的 this 指向 window 在全局环境使用 this ，它指的就是顶层的对象 window 构造函数中的 this 指的是实例对象 对象的方法包含 this ，this 的指向就是方法运行时所在的对象，该方法赋值给另一个对象，会改变 this 指向 setTimeout/setInterval 中的 this 指向 window 严格模式下的 this 全局作用域的 this 指向 window 全局作用域中函数中的 this 指向 underfined 对象的方法中的 this 指向该对象 构造函数中的 this 指向 new 出来的对象 箭头函数中的 this 是在定义函数时绑定，它会捕获其所在的上下文的 this 作为自己的 this 而不像普通函数那样是函数执行时绑定，箭头函数 this 指向它定义的上下文，而普通函数 this 指向调用它的对象 改变 this 指向的方法 使用局部变量来代替this指针 1234567891011var name = "zhar";var obj = &#123; name : "zhar", say : function()&#123; var _this = this;//使用一个变量指向 this setTimeout(function()&#123; console.log(_this.name); &#125;,0); &#125;&#125;obj.say(); call(), apply()和bind()是Function.prototype下的方法，都是用于改变函数运行时上下文，最终的返回值是你调用的方法的返回值，若该方法没有返回值，则返回undefined。 apply() 的第一个参数是null，在非严格模式下，第一个参数为null或者undefined时会自动替换为指向全局对象，apply()的第二个参数为数组或类数组。 call()是apply()的一颗语法糖，作用和apply()一样，同样可实现继承，唯一的区别就在于call()接收的是参数列表，而apply()则接收参数数组。 bind()的作用与call()和apply()一样，都是可以改变函数运行时上下文，区别是call()和apply()在调用函数之后会立即执行，而bind()方法调用并改变函数运行时上下文后，返回一个新的函数，供我们需要时再调用。 如何选用 如果不需要关心具体有多少参数被传入函数，选用apply()； 如果确定函数可接收多少个参数，并且想一目了然表达形参和实参的对应关系，用call()； 如果我们想要将来再调用方法，不需立即得到函数返回结果，则使用bind(); 总结 call()、apply()和bind()都是用来改变函数执行时的上下文，可借助它们实现继承； call()和apply()唯一区别是参数不一样，call()是apply()的语法糖； bind()是返回一个新函数，供以后调用，而apply()和call()是立即调用。 参考资料 https://www.jianshu.com/p/8d357981dedb / https://blog.csdn.net/lizhengxv/article/details/84639342 / https://www.jianshu.com/p/9b91f3df05b6 / https://www.cnblogs.com/hjson/archive/2019/01/11/10254555.html （最好） / https://baijiahao.baidu.com/s?id=1617122883116378490&amp;wfr=spider&amp;for=pc 事件冒泡的三个阶段 如何阻止]]></content>
  </entry>
  <entry>
    <title><![CDATA[Vue 组件]]></title>
    <url>%2F2019%2F06%2F24%2FVue-%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[组件的创建及使用 Vue 有两大特性1.指令 - - 用来操作 DOM 2.组件 - - 组件是 html css js 等的一个聚合体 为什么要使用组件？ 组件化 将一个具备完整功能的项目的一部分进行多处使用 加快项目的进度 可以进行项目的复用 要想实现组件化，那么我们使用的这一部分必须是完整的，我们把这个完整的整体称之为组件 插件： index.html img css js Vue 将 html css js img 整合到一起，并将此聚合体称之为，单文件组件（ xx.vue ） 基础的组件创建 命名 一个单词的大写：注意不要与原生的 h5 标签重名，比如 header footer Header Footer 小写带 - ，比如 header-title 大驼峰： FatherSon 使用 ：father-son 组件的根目录必须唯一 全局注册 123&lt;div id="app"&gt; &lt;Father&gt;&lt;/Father&gt;&lt;/div&gt; 123456789var Hello = Vue.extend(&#123; template: '&lt;div&gt; 这里是father组件 &lt;/div&gt;'&#125;) //VueComponent( option ) 组件的名称，组件的配置项 Vue.component( 'Father', Hello ) new Vue(&#123; el: '#app'&#125;) 局部注册 1234567&lt;div id="app"&gt; &lt;father-son&gt;&lt;/father-son&gt;&lt;/div&gt; &lt;div id="root"&gt; &lt;father-son&gt;&lt;/father-son&gt;&lt;/div&gt; 12345678910111213141516var Hello = Vue.extend(&#123; template: '&lt;div&gt; 这里是1903 &lt;/div&gt;' &#125;) new Vue(&#123; el: '#app', components: &#123; // key: value key是组件名称 value是组件配置项 // 'gabriel-yan': Hello, 'FatherSon': Hello &#125; &#125;) new Vue(&#123; el: '#root' &#125;) 组件中用一个components的配置项目来表示，只能在注册的范围内使用，其他地方是不能使用的 全局注册与局部注册的简写形式 1234&lt;div id="app"&gt; &lt;Father&gt;&lt;/Father&gt; &lt;father-son&gt;&lt;/father-son&gt;&lt;/div&gt; 12345678910111213Vue.component('Father',&#123; template: '&lt;div&gt; 这里是全局注册 &lt;/div&gt;'&#125;)new Vue(&#123; el: '#app', components: &#123; 'FatherSon': &#123; template: '&lt;div&gt; 这里是局部注册 &lt;/div&gt;' &#125; &#125;&#125;) 组件的嵌套 父组件里面放子组件 - - - 类似于 dom 的父子级结构 将子组件以标签的形式放在父组件的模板中使用 切记！不要放在父组件的内容中。 组件不仅可以用双标签表示，也可以使用单标签表示 12345678&lt;div id="app"&gt; &lt;!-- 下面这种写法是错误的 --&gt; &lt;Father&gt; &lt;Son&gt;&lt;/Son&gt; &lt;/Father&gt; &lt;!-- 正确的应该是 --&gt; &lt;Father&gt;&lt;/Father&gt;&lt;/div&gt; 1234567891011Vue.component('Father',&#123; template: '&lt;div&gt; Father &lt;Son&gt;&lt;/Son&gt;&lt;/div&gt;' &#125;) Vue.component('Son',&#123; template: '&lt;div&gt; son &lt;/div&gt;' &#125;) new Vue(&#123; el: '#app' &#125;) 12345678910111213new Vue(&#123; el: '#app', components: &#123; 'Father': &#123; template: '&lt;div&gt; father组件 &lt;Son /&gt;&lt;/div&gt;', components: &#123; 'Son': &#123; template: '&lt;div&gt; son组件 &lt;/div&gt;' &#125; &#125; &#125; &#125;&#125;) 掌握的组件内容 Vue 是如何扩展组件的？ Vue 为什么要以标签的形式使用组件 组件使用为何要注册 组件的特殊使用规则 （ is 规则） 12345678910&lt;div id="app"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;/tr&gt; &lt;tr is = "Hello"&gt;&lt;/tr&gt; &lt;/table&gt;&lt;/div&gt; ul&gt;li ol&gt;li table&gt;tr&gt;td select&gt;option 如上直属父子级如果直接组件以标签化形式使用，那么就会出现bug 使用is规则: 通过is属性来绑定一个组件 1&lt;tr is = "Hello"&gt;&lt;/tr&gt; 1234567Vue.component('Hello',&#123; template: '&lt;tr&gt; &lt;td&gt; 4 &lt;/td&gt; &lt;td&gt; 5 &lt;/td&gt;&lt;td&gt; 6 &lt;/td&gt;&lt;/tr&gt;'&#125;)new Vue(&#123; el: '#app'&#125;) 组件的 templatetemplate 使用 实例范围内使用 1234567891011&lt;div id="app"&gt; &lt;template&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/template&gt;&lt;/div&gt; 1234567Vue.component('Hello',&#123; template: ''&#125;) new Vue(&#123; el: '#app'&#125;) template中的内容被当做一个整体了，并且template标签是不会解析到html结构中的 实例范围外使用 12345678910&lt;div id="app"&gt;&lt;/div&gt;&lt;template&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt; 1234567Vue.component('Hello',&#123; template: ''&#125;) new Vue(&#123; el: '#app'&#125;) 实例范围外template标签是不会被直接解析的 组件要想使用template使用，我们在实例范围外使用 1234567891011&lt;div id="app"&gt; &lt;hello&gt;&lt;/hello&gt;&lt;/div&gt;&lt;template id="hello"&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt; 1234567Vue.component('Hello',&#123; template: '#hello'&#125;) new Vue(&#123; el: '#app'&#125;) 使用第二种 template 使用后，有个弊端，template 标签结构会在 html 文件中显示 使用 webpack 、gulp 等工具编译，将来要用 Vue 提供的单文件组件。 组件通信 为什么进行组件通信组件可以说是一个具有独立功能的整体，但是当我们要将这些组件拼接在一起时，这些组件相互之间要建立联系，这个联系称之为 通信 组件通信的方式 父子组件通信（ 使用 props 来实现 ）1234567891011121314151617&lt;div id="app"&gt; &lt;Father&gt;&lt;/Father&gt;&lt;/div&gt;&lt;template id="father"&gt; &lt;div&gt; &lt;h3&gt; 这里是父组件 &lt;/h3&gt; &lt;hr&gt; &lt;Son/&gt; &lt;!--可以是单标签，也可以是双标签--&gt; &lt;/div&gt;&lt;/template&gt;&lt;template id="son"&gt; &lt;div&gt; &lt;h3&gt; 这里是son组件 &lt;/h3&gt; &lt;/div&gt;&lt;/template&gt; 12345678910111213141516Vue.component('Father',&#123; template: '#father', data()&#123; //为什么将 data 定义为函数 return &#123; money: 2000 &#125; &#125;&#125;)Vue.component('Son',&#123; template: '#son' &#125;)new Vue(&#123;&#125;).$mount('#app') //app实例的手动挂载 在父组件的模板中将数据用单项数据绑定的形式，绑定在子组件身上 1234567&lt;template id="father"&gt;&lt;div&gt; &lt;h3&gt; 这里是父组件 &lt;/h3&gt; &lt;hr&gt; &lt;Son v-bind:money = "money"/&gt; &lt;!-- v-bind 可以简写为 :money = "money"--&gt;&lt;/div&gt;&lt;/template&gt; 在子组件的配置项中可以使用一个 props 配置项来接收这个数据，接收时， props 的取值可以是一个数组 1234Vue.component('Son',&#123; template: '#son', props:['money'] //指向 绑定的属性 而不是 数据（ 属性值 ）&#125;) 在子组件模板中，接收到的属性可以像全局变量一样直接使用 123456&lt;template id="son"&gt;&lt;div&gt; &lt;h3&gt; 这里是son组件 &lt;/h3&gt; &lt;p&gt; 父亲给了我 &#123;&#123; money &#125;&#125; 钱 &lt;/p&gt;&lt;/div&gt;&lt;/template&gt; props 接收的数据和子组件上绑定的自定义属性是同一个。一般将自定义属性和数据写成一致。自定义属性的书写money —&gt; moneymask-flag —&gt; maskFlag ( 驼峰命名法 ) 为什么将 data 定义为一个函数？ 组件是一个独立的个体，那么它应该拥有自己的数据，这个数据应该是一个独立的数据。 这个数据应该有独立作用域，也就是有一个独立的使用范围，这个范围就是这个组件内 js的最大特征是：函数式编程 ，而函数恰好提供了独立作用域。 为什么data要有返回值？返回值还是一个对象？ 因为Vue是通过observer来观察data选项的，所有必须要有返回值 因为Vue要通过es5的Object.defineProperty属性对对象进行getter和setter设置 子父组件通信12345678910111213141516&lt;div id="app"&gt; &lt;Father&gt;&lt;/Father&gt;&lt;/div&gt; &lt;template id="father"&gt; &lt;div&gt; &lt;h3&gt; 这是father组件 &lt;/h3&gt; &lt;Son/&gt; &lt;/div&gt;&lt;/template&gt;&lt;template id="son"&gt; &lt;div&gt; &lt;h3&gt; 这是Son组件 &lt;/h3&gt; &lt;/div&gt;&lt;/template&gt; 123456789101112131415161718192021Vue.component('Father',&#123; template:'#father', data()&#123; return&#123; money: 0 &#125; &#125;&#125;)Vue.component('Son',&#123; template:'#son', data()&#123; return&#123; hongbao: 500 &#125; &#125;&#125;)new Vue(&#123; el:'#app'&#125;) 自定义事件 自定义的事件，通过 $on 定义 $emit 触发 通过绑定在组件身上定义，通过 $emit 触发 在父组件的模板中，通过事件绑定的形式，绑定一个自定义事件在子组件身上 1234567&lt;template id="father"&gt; &lt;div&gt; &lt;h3&gt; 这是father组件 &lt;/h3&gt; &lt;p&gt; 儿子给了我 &#123;&#123; money &#125;&#125; &lt;/p&gt; &lt;!-- 注意：放在组件位置之前，放在组件之后会被覆盖 --&gt; &lt;Son @give = "getHongbao"/&gt; &lt;!--这边要注意：fn是要在父组件配置项 methods 中定义--&gt; &lt;/div&gt;&lt;/template&gt; 12345678910111213Vue.component('Father',&#123; template:'#father', data()&#123; return&#123; money: 0 &#125; &#125;, methods:&#123; getHongbao( val )&#123; this.money = val &#125; &#125;&#125;) 在子组件中的配置项 methods 中写一个事件处理程序，在事件处理程序中触发父组件绑定的自定义事件 12345678910111213Vue.component('Son',&#123; template:'#son', data()&#123; return&#123; hongbao: 500 &#125; &#125;, methods:&#123; giveFather()&#123; this.$emit('give',this.hongbao) &#125; &#125;&#125;) 将子程序组件定义的事件处理程序 giveFather ，绑定在子组件的按钮身上 123456&lt;template id="son"&gt; &lt;div&gt; &lt;button @click = "giveFather"&gt; give &lt;/button&gt; &lt;h3&gt; 这是Son组件 &lt;/h3&gt; &lt;/div&gt;&lt;/template&gt; 非父子组件通信 ref链 （ 可以实现非父子组件的通信，但是如果层级太多，比较繁琐 ）12345678910111213141516171819202122232425&lt;div id = "app"&gt; &lt;Father&gt;&lt;/Father&gt;&lt;/div&gt;&lt;template id = "father"&gt; &lt;div&gt; &lt;h3&gt; 这里是 father &lt;/h3&gt; &lt;hr&gt; &lt;Son&gt;&lt;/Son&gt; &lt;hr&gt; &lt;Girl&gt;&lt;/Girl&gt; &lt;!-- 要写双标签，不然会被覆盖 --&gt; &lt;/div&gt;&lt;/template&gt;&lt;template id = "son"&gt; &lt;div&gt; &lt;h3&gt; 这里是 son &lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;template id = "girl"&gt; &lt;div&gt; &lt;h3&gt; 这里是 girl &lt;/h3&gt; &lt;/div&gt;&lt;/template&gt; 123456789101112131415Vue.component( 'Father' ,&#123; template: '#father'&#125;)Vue.component( 'Son' ,&#123; template: '#son'&#125;)Vue.component( 'Girl' ,&#123; template: '#girl'&#125;)new Vue(&#123; el: '#app'&#125;) 通过 ref 绑定组件后，在共同的父组件的 $ref 里面可以找到子组件 12345678910&lt;template id = "father"&gt; &lt;div&gt; &lt;h3&gt; 这里是 father &lt;/h3&gt; &lt;button @click = "look"&gt; 点击查看 father 的 this 属性 &lt;/button&gt; &lt;hr&gt; &lt;Son ref = "son"&gt;&lt;/Son&gt; &lt;!-- ref 绑定名字 --&gt; &lt;hr&gt; &lt;Girl ref = "girl"&gt;&lt;/Girl&gt; &lt;!-- 要写双标签，不然会被覆盖 --&gt; &lt;/div&gt;&lt;/template&gt; 12345678Vue.component( 'Father' ,&#123; template: '#father', methods:&#123; look()&#123; console.log( this ) &#125; &#125;&#125;) 将一个子组件的数据传给父组件 1234567891011121314151617Vue.component( 'Father' ,&#123; template: '#father', methods:&#123; look()&#123; console.log( this.$refs.son.money ) &#125; &#125;&#125;)Vue.component( 'Son' ,&#123; template: '#son', data () &#123; return&#123; money: 1000 &#125; &#125;&#125;) 父组件将数据传给另一个子组件 12345678910&lt;template id = "father"&gt; &lt;div&gt; &lt;h3&gt; 这里是 father &lt;/h3&gt; &lt;button @click = "look"&gt; 点击查看 father 的 this 属性 &lt;/button&gt; &lt;hr&gt; &lt;Son ref = "son"&gt;&lt;/Son&gt; &lt;hr&gt; &lt;Girl ref = "girl" :money = "this.$refs.son.money"&gt;&lt;/Girl&gt; &lt;/div&gt;&lt;/template&gt; 但是此时发现直接绑定,无法取到数据（ money ）于是在父组件中新增 data 并将要传的数据赋值给 data ,并绑定给需要数据的子组件 12345678910111213141516171819&lt;template id = "father"&gt; &lt;div&gt; &lt;h3&gt; 这里是 father &lt;/h3&gt; &lt;button @click = "look"&gt; 点击查看 father 的 this 属性 &lt;/button&gt; &lt;hr&gt; &lt;Son ref = "son"&gt;&lt;/Son&gt; &lt;hr&gt; &lt;Girl ref = "girl" :n = "n"&gt; &lt;/Girl&gt; &lt;/div&gt;&lt;/template&gt;&lt;template id = "girl"&gt; &lt;div&gt; &lt;h3&gt; 这里是 girl &lt;/h3&gt; &lt;button @click = "out"&gt; 显示从 son 拿到的 money &lt;/button&gt; &lt;p&gt; 从 son 拿到的 money &#123;&#123; n &#125;&#125; &lt;/p&gt; &lt;/div&gt;&lt;/template&gt; 123456789101112131415161718192021222324252627Vue.component( 'Father' ,&#123; template: '#father', data () &#123; return&#123; n:0 &#125; &#125;, methods:&#123; look()&#123; this.n = this.$refs.son.money &#125; &#125;&#125;)Vue.component( 'Girl' ,&#123; template: '#girl', data () &#123; return&#123; n:0 &#125; &#125;, methods : &#123; out () &#123; this.n = this.$attrs.n &#125; &#125;&#125;) bus 事件bus事件总线，我们是通过 $on来定义事件， 通过 $emit来触发事件 12345678910111213141516&lt;div id = "app"&gt; &lt;Boy&gt;&lt;/Boy&gt; &lt;Girl&gt;&lt;/Girl&gt;&lt;/div&gt;&lt;template id = "boy"&gt; &lt;div&gt; &lt;h3&gt; 这里是 boy &lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;template id = "girl"&gt; &lt;div&gt; &lt;h3&gt; 这里是 girl &lt;/h3&gt; &lt;/div&gt;&lt;/template&gt; 1234567891011Vue.component( 'Boy' ,&#123; template: '#boy'&#125;)Vue.component( 'Girl' ,&#123; template: '#girl'&#125;)new Vue(&#123; el: '#app'&#125;) 在其中一个组件的挂载钩子函数上做事件的声明 12345678910111213&lt;template id = "boy"&gt; &lt;div&gt; &lt;h3&gt; 这里是 boy &lt;/h3&gt; &lt;button @click = "give"&gt; 给 girl money &lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;template id = "girl"&gt; &lt;div&gt; &lt;h3&gt; 这里是 girl &lt;/h3&gt; &lt;p v-show = "flag"&gt; 拿到 &#123;&#123;money&#125;&#125; &lt;/p&gt; &lt;/div&gt;&lt;/template&gt; 1234567891011121314151617181920212223Vue.component( 'Girl' ,&#123; template: '#girl', data () &#123; return&#123; flag : false, money : 0 &#125; &#125;, mounted () &#123; //当前组件挂载结束，也就是我们可以在页面中看见真实 DOM // mounted 这个钩子函数的触发条件是组件创建时自动触发 //事件的声明 var _this = this bus.$on( 'set' ,function( money )&#123; _this.flag = true //如果直接用 this 这里的 this 指向 bus ，但是我们需要这个 this 应该指向 Girl 组件 _this.money = money &#125;) &#125;&#125;) 在另一个组件中，通过 bus.$emit(‘set’) 来触发这个自定义事件 123456789101112131415var bus = new Vue() // bus 原型上是不是有 $on $emitVue.component( 'Boy' ,&#123; template: '#boy', data () &#123; return &#123; money : 1000 &#125; &#125;, methods : &#123; give () &#123; bus.$emit( 'set' , this.money) &#125; &#125;&#125;) 多组件状态共享 非常规组件通信 自定义事件实现子父组件通信 123456789101112131415161718&lt;div id = "app"&gt; &lt;Father&gt;&lt;/Father&gt;&lt;/div&gt; &lt;template id = "father"&gt; &lt;div&gt; &lt;h3&gt; 这里是 father 组件 &lt;/h3&gt; &lt;p&gt; father 收到 son 的 &#123;&#123;n&#125;&#125; 元红包 &lt;/p&gt; &lt;Son :add = "add"&gt;&lt;/Son&gt; &lt;/div&gt;&lt;/template&gt;&lt;template id = "son"&gt; &lt;div&gt; &lt;h3&gt; 这里是 son 组件 &lt;/h3&gt; &lt;button @click = "add ( money )"&gt; 给钱 &lt;/button&gt; &lt;/div&gt;&lt;/template&gt; 123456789101112131415161718192021222324252627Vue.component('Father',&#123; template: '#father', data () &#123; return &#123; n: 0 &#125; &#125;, methods: &#123; add ( val ) &#123; this.n = val &#125; &#125;&#125;)Vue.component('Son',&#123; template: '#son', data () &#123; return &#123; money: 1000 &#125; &#125;, props: ['add']&#125;)new Vue(&#123; el: '#app'&#125;) 父组件将一个方法通过绑定的形式给子组件 子组件先是通过 props 接收这个方法，再执行这个方法 不推荐使用 MVVM框架是单向数据流，上述方法违背了单项数据流]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue 组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟DOM与diff算法]]></title>
    <url>%2F2019%2F06%2F24%2F%E8%99%9A%E6%8B%9FDOM%E4%B8%8Ediff%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[虚拟 DOM 与 diff 算法虚拟DOM 虚拟DOM的引入更少的DOM操作会更加减少时间花费与性能损耗 应先操作数据 再 操作 DOM 于是 满满的前端将 虚拟DOM概念引入在框架中 vdomvdom是一个对象模型，用来摸你真实dom节点的操作 diff 算法diff 算法是比较两个文件的差异，并将这两个文件的不同之处生成一个补丁对象 （ patch ） diff 算法来源于后端，前端将其应用于虚拟 dom 的 diff 算法 vue 中将虚拟 dom 的 diff 算法放在了 patch.js 文件中 diff 算法是同级比较，给每一层打上标记 （数字） ，这个数字就是 key vdom 的使用流程 获取数据 ( ajax fetch ) 创建vdom 通过 render 函数解析 jsx， 将其转换成 vdom 结构 vue中使用的是 jsx 语法 （ javascript + xml ） 初次渲染 vdom （ vdom 渲染成真实 dom） render 函数 数据更改，再次创建 vdom 使用 diff 算法比对两次 vdom ，生成 patch 对象 根据 key 将 patch 对象渲染到页面中改变的结构上而其他地方是不作任何修改的 （ 虚拟 dom 的惰性原则） vue是MVVM框架，Vue高性能的原因之一就是vdom Vue vdom vs React vdom 有何不一样？]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>虚拟DOM</tag>
        <tag>diff算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟DOM与diff算法]]></title>
    <url>%2F2019%2F06%2F24%2FVue%E5%B8%B8%E8%A7%81%E6%8A%A5%E9%94%99%2F</url>
    <content type="text"><![CDATA[Error in v-on handler (Promise/async): “ReferenceError: search is not 写着search的地方没加引号 常用正则 https://mp.weixin.qq.com/s?__biz=MzAwNjI5MTYyMw==&amp;mid=2651497603&amp;idx=1&amp;sn=8a9d01a671623cf1bb1d259e8a7d61bf&amp;chksm=80f1ad4bb786245de894ffb446f62fe9e6ea2177959f262933a9c44405dc0a9a00d2e31bd51a&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;key=5e1a44c6b19fdb9003d45cdb093678470d418a6855955342e7cc1fc45bc12223ae400baf26ff3fab236fee0e2ea3811da171876923a8b2338735eb3c4a600f269125e9b445a67ecbf9787e8f558d40a6&amp;ascene=1&amp;uin=MzEyMTE5MTg4OQ%3D%3D&amp;devicetype=Windows+10&amp;version=62060833&amp;lang=zh_CN&amp;pass_ticket=ar4Tk1wvYM%2BI0yjRSPKvgqtI7ZJ3gFaf%2BRfJ6nm7v7XZPaP5U1aPRazcw7OOvAYE elemengt-ui组件 表单添加正则表达式验证 123456&lt;el-form-item label="联系电话" prop="shop_tel"&gt; &lt;el-input v-model="ruleForm.shop_tel" &gt; &lt;/el-input&gt;&lt;/el-form-item&gt; 12345rules:&#123; shop_tel:[ &#123; required: true, message: '请输入联系电话', trigger: 'blur' &#125;, &#123; pattern: /^1((3[\d])|(4[5,6,9])|(5[0-3,5-9])|(6[5-7])|(7[0-8])|(8[1-3,5-8])| (9[1,8,9]))\d&#123;8&#125;$/, message: '目前只支持中国大陆的手机号码',trigger: ['blur'] &#125; ]&#125; element-ui 的Cascader 级联选择器 内容改变 12345678&lt;div class="block"&gt; &lt;span class="demonstration"&gt;默认 click 触发子菜单&lt;/span&gt; &lt;el-cascader v-model="value" &lt;!-- value可以改动但javascript的value必须同时改动 --&gt; :options="options" &lt;!-- options 可以改动但javascript的options必须同时改动，两个属性同时改动 --&gt; @change="handleChange"&gt; &lt;/el-cascader&gt;&lt;/div&gt; 123456789101112131415export default &#123; data() &#123; return &#123; value: [], options: [&#123; value: 'zhinan', label: '指南' ]&#125; &#125;, methods: &#123; handleChange(value) &#123; console.log(value); &#125; &#125; &#125;; element-ui 级联选择器 动态获取 123456789101112&lt;el-cascader v-model="ruleForm.shop_region" :options="get_shop_region" :props="&#123; label:'name', value:'name', children:'sub_categories' &#125;" @click="handleChange"&gt;&lt;/el-cascader&gt; options:动态获取的数据 prop:应用动态获取的数据 Duplicate keys detected: ‘**’. This may cause an update error.这个错误是我使用vue-cli项目时出现的错误，看错误的的报告中关键字’keys’,联系错误的时机，可以知道这个错误出现在我使用vue的循环中，循环再vue或者小程序中饭为了保证每一项的独立性，都会推荐使用key，所以综上所述，很可能是key出现问题]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>虚拟DOM</tag>
        <tag>diff算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue]]></title>
    <url>%2F2019%2F06%2F22%2FVue%2F</url>
    <content type="text"><![CDATA[Vuevue初步认识前端发展历史html html [1990]—-&gt; html5 [2008.1.12] css css 1.0 1996 css 2.0 1998 css 3.0 2001 EcmaScript1.1997年诞生2.2015 EcmaScript 20153.2016 EcmaScript 2016 dart语言 vs javascript 架构思想的出现随着前端项目的逻辑越来越复杂和难以维护，那么前端这边引进了后端的架构思想（ MV* ） M Model 数据层 V View 视图层 VM ViewModel 视图模型（ 业务逻辑 VM 是 由 P 改名得来的） P Presenter 提出者（ Controller 改名得来的 ） C Controller 控制器 ( 业务逻辑 ) Backbone.js MVP 2010.10 Angular.js( 1.0 ) MVC 2010.10 Angular.ts ( 2.0 ) MVC -&gt; MVVM 2016 目前已经更新到了 Angular7 ( 也属于angular2.0 版本 ) Vue 1.0 MVVVM 2014/07 Vue 2.0 MVVM 2016/09 React 2012 不太认可前端MVC这种架构思想， 你可以将React单纯看做是MVC中V github统计量 （ 国际使用量 ）不代表大陆地区 单位是： K angular.js angular.ts vue React 59.6 49.1 142 131 学习难度： Vue &lt; React &lt; Angular( 2.0 ) 前端流行 移动 web &amp;&amp; hybird app( 混合app ) app native app ( 安卓 ios java ME) webapp ( 应用在浏览器中的app ) Hybird app ( 混合app ) webapp 嵌入 第三方原生应用库（ 可以访问原生设备（手机） 的接口权限，比如：照相机 ） MV*的图示MVC C改名为P MVP | P更像是媒人了（ 连接 M V 的桥梁） MVVM VM 是 由 p改名得来的 VM 和 V 的关系更加的亲密 “MVVM”:双向数据绑定，View的变动，映射在 ViewModel，反之一样 注意： ​ 以上的这几个框架都是： 单向数据流（ 数据由 父级 流向 子级 ） 初识Vue.js Vue.js是尤雨溪的个人项目 Vue.js是一个MVVM框架 Vue.js也是一个javascript的渐进式框架（ 越学越难 ） 前端还有一个比较知名的MVVM的个人项目： 司徒正美 avonlon.js vue.js安装 script标签引入（ cdn| 下载 ） 模块化安装 npm/cnpm/yarn mutache 语法糖mustache语法糖对数据类型的支持（ js语法的支持 ）数据类型： 第一种划分： 基础数据类型： number string boolean 复杂数据类型: Object( array function ) 特殊数据类型: null undefined 第二种划分： 初始数据类型: number string boolean null undefined 引用数据类型: object( array function ) ​ 结论 mustache支持我们js的数据类型的 conosle.log 和 alert 在我们mustache语法中是不支持的 mustache 绑定 dom的属性-v-html 12345&lt;div id="app"&gt; &lt;p v-html = "h"&gt;&lt;/p&gt; &lt;p v-text = "msg"&gt;&lt;/p&gt; &lt;p v-text = " flag &amp;&amp; 1 || 2 " &gt; &lt;/p&gt;&lt;/div&gt; 12345678var vm = new Vue(&#123; el: '#app', data: &#123; msg: 'hello Vue.js', h: '&lt;h3&gt; hello Vue.js &lt;/h3&gt;', flag: true &#125;&#125;)分析 发现dom元素直接有了一个内容，这种属性绑定就是为了操作dom 结论 这种属性绑定的形式就是为了操作dom，我们给这种属性起了一个好听的名字 Vue 1.0 叫它 属性指令（ 借鉴Angular来的 ） Vue 2.0 统称为 ‘指令’ 指令是用一个 v-xxx 表示 指令是用来操作dom Vue中不允许直接操作dom mustache语法 — 属性写法 的属性值是直接写数据的，不需要使用 {{ }} MVVM分别代表 vue是 MVVM 框架， 那么谁是 M 谁是 V 谁是 VM M： Model 数据 V： View 视图 VM: ViewModel 视图模型（ new Vue() ） 指令 v-html: 可以解析标签型数据( 可以将一个数据展示在一个dom的内容中（ 相当于使用了 innerHTML ）) v-text：可以将一个数据展示在一个dom的内容中（ 相当于使用了 innerHTML ） 条件渲染的指令 v-show 可以控制一个dom的显示隐藏（ 这个指令操作的是dom的display属性 ） v-if 可以控制一个dom的存在与否（ 创建 和 销毁 ） v-if vs v-show 区别 v-if 操作的是dom元素（ 组件 ） 的创建或是销毁 v-show 操作的是dom元素的display属性 v-if可以有多种使用形式： 单路分支， 多路分支， 双路分支 v-show 只能写一个单路形式 v-for 数组 v-for = “ (item,index) in arr “ item是arr中每一个元素 对象 v-for = “(item,key,index) in obj “ item是obj的属性值 json类型数据 嵌套类型数据 方法 1for( var i = 0 ; i &lt; 100; i ++ )&#123;&#125; 1for( var i in arr )&#123;&#125; 1for ( var i of arr ) &#123;&#125; key 给没一个循环的列表添加一个唯一的标识 使用指令 v-bind 来绑定 key 1&lt;div v-for = " (item,index) in lists" v-bind: key = " item.id "&gt;&lt;/div&gt; 如果有id，那么我们就使用id，如果没有，我们才会选择index v-bind: 单项数据绑定： 将一个数据绑定在一个dom的属性上 简写 1&lt;div v-for = " (item,index) in lists" :key = " item.id "&gt;&lt;/div&gt; vue中如何给dom添加类名 直接在dom上绑定类名 vue中类名绑定 - 对象形式 目的： dom身上属性class 要和 数据绑定 解决：v-bind 数据中key，和绑定的对象中的key一样，但是这两个东西不一样 vue中类名绑定的形式 - 数组的形式 【 推荐 】 格式： v-bind:class = “[ 数据 ]” 类名绑定不会覆盖原先的类名 通过数据来操作类名，类名操作dom 样式的绑定 1v-bind: style = "" 对象的形式 数组的形式 123456789101112new Vue(&#123; el: '#app', data: &#123; size: &#123; width: '100px', height: '100px' &#125;, bg: &#123; background: 'purple' &#125; &#125; &#125;) 事件 事件绑定 12345dom.onclick = function () &#123;&#125;dom: 事件源on: 绑定事件的形式click: 事件类型function（）&#123;&#125; 事件处理函数 事件监听 ： addeventListener 直接在标签中绑定事件 1&lt;div onclick = "事件名称"&gt;&lt;/div&gt; vue采用了第三种，也是通过属性的形式绑定在dom身上 1&lt;div v-on:click = "事件名称"&gt;&lt;/div&gt; 1v-on:eventType = " handlerName " 简写: v-on: — &gt; @ 事件对象也可以正常使用，在事件处理程序中， 写e就可以了 12345678 el: '#app', methods: &#123; // 存放事件处理程序 helloHandler ( e ) &#123; console.log( e ) &#125; &#125;&#125;) 事件处理程序中有三个参数，第三个参数才是事件对象e,如何实现 函数执行时，传入一个实际参数 $event 来代表事件对象 阻止事件冒泡 @click.stop v-model 双向数据绑定 默认绑定value值 v-model应用于表单元素 1234&lt;div id="app"&gt; &lt;input type="text" v-model = "msg"&gt; &lt;p&gt; &#123;&#123; msg &#125;&#125; &lt;/p&gt;&lt;/div&gt; 123456new Vue(&#123; el: '#app', data: &#123; msg: 'hello Vue.js' &#125; &#125;) computed 计算属性 计算属性中存放的是函数（ 书写逻辑 ） 计算属性可以直接像全局变量一样使用，直接将方法名当做全局变量一样使用]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js]]></title>
    <url>%2F2019%2F06%2F22%2FNode-js%2F</url>
    <content type="text"><![CDATA[Node 简介客户端的JavaScript是怎样的 什么是 JavaScript？+是一个脚本语言+运行在浏览器（浏览器的js解析内核 v8）+实现用户的交互 （interactive） 变量 赋值 循环 逻辑 判断 分支 对象 函数。。。。 dom 操作 bom 操作 ajax JavaScript 的运行环境？+浏览器内核解析内核 es6 浏览器中的 JavaScript 可以做什么？ 浏览器中的 JavaScript 不可以做什么？（不安全）+访问数据库+不能对文件进行操作+对os 进行操作+原因 是不安全 和浏览器运行机制有关 在开发人员能力相同的情况下编程语言的能力取决于什么？ +cordova hbuilder 平台 platform+java java虚拟机 （运行平台）+php php虚拟机+c# .net framework mono+js 解析内核 chrome v8 JavaScript 只可以运行在浏览器中吗？+不是 为什么是JavaScript node js 不是因为js 产生的 node 选择了js Ryan dahl 2009 2 月份 node有想法 2009 5 月份 githup 开源 2009 11月份 jsconf 讲解推广node 2010年底 被xxx公司收购 2018 发布有重大bug npm （ npm 最大的开源 ， 包管理器 ） https://www.npmjs.com/ github 世界上最大的同性交友网站( github.com) 码云( gitee.com) what is node ？ Node.js 是一个基于Chrome V8 引擎的JavaScript运行环境 Node.js使用了一个事件驱动、非阻塞式I/O的模型,使其轻量又高效 事件驱动： 任务执行，发布者，订阅者，事件驱动 （ on emit ） 非阻塞： 执行某一个任务的同时也可以执行其他任务 阻塞： 执行某一个任务，这个任务如果没有执行完成，其他任务必须等待 同步： 异步 I/O: 输入/输出（ 数据库操作，文件系统操作等 ） 非阻塞I/O模型： 当我们使用Node.js来实现数据库操作、文件系统等操作时，要进行的异步操作，异步操作的核心传统实现方式就是回调函数 Node.js的包管理工具npm,是全球最大的开源库生态系统 第三方： 国外的 建议： 切换国内的， 淘宝国内镜像源 nrm 安装cnpm $ npm install -g cnpm --registry=https://registry.npm.taobao.org 查看是否cnpm安装成功 cnpm -v 官网 http://nodejs.cn/ npm 插件官网：https://www.npmjs.com/ 环境配置Node的安装 安装包安装 官网下载对应的安装包 一路next nvm安装(有一个类似的工具：nvm) Node Version Manager（Node版本管理工具） 由于以后的开发工作可能会在多个Node版本中测试，而且Node的版本也比较多，所以需要这么款工具来管理 默认安装结束之后，默认路径： C:\Users\xxx\AppData\Roaming\nvm nvm安装教程博客：https://blog.csdn.net/qq_32682137/article/details/82684898 问题： 如果有的同学，任意目录不能使用nvm，只有在nvm安装目录下才能使用，那么就是环境变量有问题？ 在高级环境变量中的系统变量中创建两个变量 12341. NVM_HOME 变量名： NVM_HOME 变量值： nvm安装目录路径2. NVM_SYMLINK 变量名： NVM_SYMLINK 变量值： Node.js的安装目录 在系统变量的path路径中将上面创建的变量引用进来 1;%NVM_HOME%%NVM_SYMLINK%添加到系统变量 pth路径的后面 切记： 不要将path路径删除了 nvm使用 12345678910nvm list 列出当前电脑中所有的Node.js的版本nvm install version 安装某一个版本的Node.js , 举例： 安装10.12.0版本 nvm install 10.12.0nvm use version 切换某一个Node.js版本 切换后切记： 要确认Node运行十分正常 node -v npm -v 如果以上两者输出正常，那么久切换成功了 如果不正常呢？换版本下载安装（ 必须在8.9+ 以上） 相关版本 node版本常识 偶数版本为稳定版 （0.6.x ，0.8.x ，0.10.x） 奇数版本为非稳定版（0.7.x ，0.9.x ，0.11.x） LTS（Long Term Support） LTS和Current区别 操作方式： 重新下载最新的安装包； 覆盖安装即可； 问题： 以前版本安装的很多全局的工具包需要重新安装 无法回滚到之前的版本 无法在多个版本之间切换（很多时候我们要使用特定版本） Windows下常用的命令行操作 切换当前目录（change directory）：cd 创建目录（make directory）：mkdir 查看当前目录列表（directory）：dir 别名：ls（list） 清空当前控制台：cls 别名：clear 删除文件：del 别名：rm 注意：所有别名必须在新版本的 PowerShell （linux系统）中使用 电脑： ​ cmd里面用的叫做 DOS命令 ​ cmd终端唤醒： win键 + R , 输入cmd 回车 ​ mkdir 创建目录 ​ dir 列出当前目录的列表 ​ cls 清空终端命令 ​ del 删除某一个文件 ​ git / powershell 用的是linux命令 ​ mkdir 创建目录 ​ ls 查看当前目录列表 ​ clear 清空当前控制台 ​ rm -rf 文件名称 删除某一个文件或是目录 ​ 两种类型的命令中， cd是一个意思 常见问题 环境变量丢失 部分电脑安装完毕之后没有环境变量需要手动配置 Windows中环境变量分为系统变量和用户变量 环境变量的变量名是不区分大小写的 PATH 变量：只要添加到 PATH 变量中的路径，都可以在任何目录下 目的可以在任何地方调起node命令 Node.js实时监听（ 自动刷新 ）借助第三方工具实现： ​ nodemon 【 推荐 】 ​ cnpm i nodemon -g ​ nodemon 文件名称 ​ supervisor ​ cnpm i supervisor -g ​ supervisor 文件名称 ##模块,包 commonjs commonjs规范前端模块化：AMD,CMD,Commonjs Node 应用由模块组成，采用 CommonJS 模块规范。 定义module每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。 暴露接口 CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。 123456 var x = 5;var addX = function (value) &#123; return value + x;&#125;;module.exports.x = x;module.exports.addX = addX; 引用 require方法用于加载模块。 123 var example = require(&apos;./example.js&apos;);console.log(example.x); // 5console.log(example.addX(1)); // 6 模块的分类 内置模块 1234const process = require(&apos;process&apos;)const path = require(&apos;path&apos;)console.log(process.version)console.log(path.resolve(&apos;../&apos;)) 第三方模块 12345678910 const request=require(&quot;request&quot;);console.log(request)request.get(&apos;http://api.douban.com/v2/movie/in_theaters&apos;, (err, response, body) =&gt; &#123; if (!err) &#123; // console.log(body); console.log(JSON.parse(body)) &#125; else &#123; console.log(err); &#125;&#125;) 自定义模块 ###npm 使用入门 官网:https://www.npmjs.com/ 安装：无需安装 查看当前版本： 1$ npm -v 更新： 1$ npm install npm@latest -g 初始化工程 123$ npm init$ npm init --yes 默认配置 安装包 使用npm install会读取package.json文件来安装模块。安装的模块分为两类 dependencies和devDependencies，分别对应生产环境需要的安装包和开发环境需要的安装包。 1234567$ npm install$ npm install &lt;package_name&gt; $ npm install &lt;package_name&gt; --save$ npm install &lt;package_name&gt; --save-dev 更新模块 1$ npm update 卸载模块 123$ npm uninstall &lt;package_name&gt;$ npm uninstall --save lodash 配置npm源 临时使用, 安装包的时候通过–registry参数即可 $ npm install express –registry https://registry.npm.taobao.org 全局使用 12345$ npm config set registry https://registry.npm.taobao.org// 配置后可通过下面方式来验证是否成功npm config get registry// 或npm info express cnpm 使用 12345// 安装cnpm npm install -g cnpm --registry=https://registry.npm.taobao.org // 使用cnpm安装包 cnpm install express 常用的内置模块node 常用内置api (1) URL 网址解析 解析URL相关网址信息 url.parse(urlString[, parseQueryString[, slashesDenoteHost]]) url.format(urlObject) url.resolve(from, to)(2) QueryString 参数处理 querystring.escape(str) querystring.unescape(str) querystring.parse(str[, sep[, eq[, options]]]) querystring.stringify(obj[, sep[, eq[, options]]])(3) HTTP 模块概要 http.createServer([options][, requestListener]) http.get(options[, callback]) 简易的爬虫 代理跨域处理(4) 事件 events 模块(5) 文件fs模块 打印目录树(6) Stream 流模块 歌词播放 音乐下载(8) request 方法 2、Node.js 基础应用1、应用 HTTP 模块编写一个小爬虫工具(1) 利用爬虫获取“拉勾网”首页列表数据(2) 通过 npm 安装 cheerio 模块获得数据2、后端表单的提交要求:(1) 应用 request post 模拟提交表单 文件读取Node中文件读取的方式主要有： fs.readFile(file[, options], callback(error, data)) 1234fs.readFile('c:\\demo\1.txt', 'utf8', (err, data) =&gt; &#123; if (err) throw err; console.log(data);&#125;); fs.readFileSync(file[, options]) 1234567try &#123; const data = fs.readFileSync('c:\\demo\1.txt', 'utf8'); console.log(data);&#125; catch(e) &#123; // 文件不存在，或者权限错误 throw e;&#125; fs.createReadStream(path[, options]) 12345678const stream = fs.createReadStream('c:\\demo\1.txt');let data = ''stream.on('data', (trunk) =&gt; &#123; data += trunk;&#125;);stream.on('end', () =&gt; &#123; console.log(data);&#125;); 由于Windows平台下默认文件编码是GBK，在Node中不支持，可以通过iconv-lite解决 Readline模块逐行读取文本内容12345678910const readline = require('readline');const fs = require('fs');const rl = readline.createInterface(&#123; input: fs.createReadStream('sample.txt')&#125;);rl.on('line', (line) =&gt; &#123; console.log('Line from file:', line);&#125;); 文件写入Node中文件写入的方式主要有： fs.writeFile(file, data[, options], callback(error)) 123fs.writeFile('c:\\demo\a.txt', new Date(), (error) =&gt; &#123; console.log(error);&#125;); fs.writeFileSync(file, data[, options]) 123456try &#123; fs.writeFileSync('c:\\demo\a.txt', new Date());&#125; catch (error) &#123; // 文件夹不存在，或者权限错误 console.log(error);&#125; fs.createWriteStream(path[,option]) 123456var streamWriter = fs.createWriteStream('c:\\demo\a.txt');setInterval(() =&gt; &#123; streamWriter.write(`$&#123;new Date&#125;\n`, (error) =&gt; &#123; console.log(error); &#125;);&#125;, 1000); node中的异步操作 fs模块对文件的几乎所有操作都有同步和异步两种形式 例如：readFile() 和 readFileSync() 区别： 同步调用会阻塞代码的执行，异步则不会 异步调用会将读取任务下达到任务队列，直到任务执行完成才会回调 异常处理方面，同步必须使用 try catch 方式，异步可以通过回调函数的第一个参数 123456789101112131415console.time('sync');try &#123; var data = fs.readFileSync(path.join('C:\\Users\\iceStone\\Downloads', 'H.mp4')); // console.log(data);&#125; catch (error) &#123; throw error;&#125;console.timeEnd('sync');console.time('async');fs.readFile(path.join('C:\\Users\\iceStone\\Downloads', 'H.mp4'), (error, data) =&gt; &#123; if (error) throw error; // console.log(data);&#125;);console.timeEnd('async'); promise 对象的使用参考资料：JavaScript Promise迷你书 PromisePromise是抽象异步处理对象以及对其进行各种操作的组件。Promise并不是从JavaScript中发祥的概念。Promise最初被提出是在 E语言中， 它是基于并列/并行处理设计的一种编程语言。现在JavaScript也拥有了这种特性，这就是JavaScript Promise 使用了回调函数的异步处理 123456789----getAsync("fileA.txt", function(error, result)&#123; if(error)&#123;// 取得失败时的处理 throw error; &#125; // 取得成功时的处理&#125;);----&lt;1&gt; 传给回调函数的参数为(error对象， 执行结果)错误优先处理 使用了回调函数的异步处理 123456789----var promise = getAsyncPromise("fileA.txt"); promise.then(function(result)&#123; // 获取文件内容成功时的处理&#125;).catch(function(error)&#123; // 获取文件内容失败时的处理&#125;);----&lt;1&gt; 返回promise对象 创建Promise对象 * 123456var promise = new Promise(function(resolve, reject) &#123; // 异步处理 // 处理结束后、调用resolve 或 reject resolve(&apos;成功处理&apos;) reject(&apos;错误处理&apos;)&#125;); 使用实例 * 创建一个priomise 对象并返回new Promise(fn) 在fn 中指定异步等处理 处理结果正常的话，调用resolve(处理结果值) 处理结果错误的话，调用 reject(Error对象) 1234567891011121314function asyncFunction() &#123; return new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; resolve('Async Hello world'); &#125;, 16); &#125;);&#125;asyncFunction().then(function (value) &#123; console.log(value); // =&gt; 'Async Hello world'&#125;).catch(function (error) &#123; console.log(error);&#125;); Promise的状态 用new Promise 实例化的promise对象有以下三个状态。 “has-resolution” - Fulfilled resolve(成功)时。 “has-rejection” - Rejected reject(失败)时 “unresolved” - Pending 既不是resolve也不是reject的状态。也就是promise对象刚被创建后的初始化状态等 promise对象的状态，从Pending转换为Fulfilled或Rejected之后， 这个promise对象的状态就不会再发生任何变化。 也就是说，Promise与Event等不同，在.then 后执行的函数可以肯定地说只会被调用一次。 另外，Fulfilled和Rejected这两个中的任一状态都可以表示为Settled(不变的)。 Settledresolve(成功) 或 reject(失败)。 从Pending和Settled的对称关系来看，Promise状态的种类/迁移是非常简单易懂的。 当promise的对象状态发生变化时，用.then 来定义只会被调用一次的函数。 路径模块在文件操作的过程中，都必须使用物理路径（绝对路径），path模块提供了一系列与路径相关的 API 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879console.log('join用于拼接多个路径部分，并转化为正常格式');const temp = path.join(__dirname, '..', 'lyrics', './友谊之光.lrc');console.log(temp);console.log('获取路径中的文件名');console.log(path.basename(temp));console.log('获取路径中的文件名并排除扩展名');console.log(path.basename(temp, '.lrc'));console.log('====================================');console.log('获取不同操作系统的路径分隔符');console.log(process.platform + '的分隔符为 ' + path.delimiter);console.log('一般用于分割环境变量');console.log(process.env.PATH.split(path.delimiter));console.log('====================================');console.log('获取一个路径中的目录部分');console.log(path.dirname(temp));console.log('====================================');console.log('获取一个路径中最后的扩展名');console.log(path.extname(temp));console.log('====================================');console.log('将一个路径解析成一个对象的形式');const pathObject = path.parse(temp);console.log(pathObject);console.log('====================================');console.log('将一个路径对象再转换为一个字符串的形式');// pathObject.name = '我终于失去了你';pathObject.base = '我终于失去了你.lrc';console.log(pathObject);console.log(path.format(pathObject));console.log('====================================');console.log('获取一个路径是不是绝对路径');console.log(path.isAbsolute(temp));console.log(path.isAbsolute('../lyrics/爱的代价.lrc'));console.log('====================================');console.log('将一个路径转换为当前系统默认的标准格式，并解析其中的./和../');console.log(path.normalize('c:/develop/demo\\hello/../world/./a.txt'));console.log('====================================');console.log('获取第二个路径相对第一个路径的相对路径');console.log(path.relative(__dirname, temp));console.log('====================================');console.log('以类似命令行cd命令的方式拼接路径');console.log(path.resolve(temp, 'c:/', './develop', '../application'));console.log('====================================');console.log('获取不同平台中路径的分隔符（默认）');console.log(path.sep);console.log('====================================');console.log('允许在任意平台下以WIN32的方法调用PATH对象');// console.log(path.win32);console.log(path === path.win32);console.log('====================================');console.log('允许在任意平台下以POSIX的方法调用PATH对象');console.log(path === path.posix); express 官网:http://www.expressjs.com.cn/ express 环境搭建安装 1$ npm install express --save 快速开始 1234const express = require('express') const app = express() app.get('/', (req, res) =&gt; res.send('Hello World!')) app.listen(3000, () =&gt; console.log('Example app listening on port 3000!')) express 路由配置12345678910111213141516171819let express=require('express')let router=express.Router()// 该路由使用的中间件router.use((req,res,next)=&gt;&#123; next()&#125;);// 定义网站主页的路由router.post('/addFood', function(req, res) &#123; console.log('hahaha') // res.send('这里是admin的登录');&#125;);// 定义 about 页面的路由router.post('/regist', function(req, res) &#123; res.send('这里是admin的注册侧');&#125;);module.exports = router;app.use('/admin',admin) 传递数据的获取12345678getreq.querypostreq.bodybody-parser设置中文格式res.set(&apos;Content-Type&apos;,&apos;text/plain,charset=utf8&apos;) 请求模拟工具 insomina静态资源配置12345app.use(express.static('public'))app.use('/static', express.static('public'))app.use('/static', express.static(path.join(__dirname, 'public'))) mongod安装配置 在Mongodb官网下载最新版本的Mongodb下载地址 下载msi的window安装包，可以装到C盘或者D盘目录下 配置由于我是安装在D盘的环境下 123&gt; D:\Program Files (x86)\MongoDB\Server\3.2\bin&gt; &gt; 所以在bin文件夹下找到mongod.exe命令，然后通过管理员执行mongod --dbpath x路径x，路径可以是任何地方，我这里选择在D盘的MongoDB目录下，当然路径不要包含特殊的字符串，比如Program Files (x86)也不行 123&gt; mongod --dbpath D:\mongodb\data\db&gt; &gt; 命令行经过上面的配置之后，就可以返回bin目录下找到mongo.exe命令，并管理员下执行，就可以出现mongodb的命令行模式 123&gt; D:\Program Files (x86)\MongoDB\Server\3.2\bin&gt; &gt; 然后就可以使用下面的命令来测试了 mongod 1234&gt; db.help()//帮助&gt; db.stats()//统计&gt; &gt; 显示数据库123&gt; show dbs&gt; &gt; 检查当前选择的数据库 123&gt; db&gt; &gt; 添加数据库数据库名为数据库创建的名字，使用该命令后会默认切换到对应的数据库，并且在数据库中添加选项，数据库信息才显示，如果默认就有该数据库，那就是切换到对应的数据库里面 12&gt; use 数据库名&gt; 删除数据库先切换到对应的数据库，然后再执行db.dropDatabase()删除该数据库 1234&gt; use 数据库名&gt; //switched to db 数据库名&gt; db.dropDatabase()&gt; 显示集合用一下命令可以检查创建的集合 12&gt; show collections&gt; 添加集合在创建完数据库之后，我们就可以创建集合 12&gt; db.createCollection(集合名字name，设置参数options[对象类型])&gt; name是要创建的集合的名称。 options是一个文档，用于指定集合的配置 参数 类型 描述name String 要创建的集合的名称options Document (可选)指定有关内存大小和索引的选项options参数是可选的，因此只需要指定集合的名称。 以下是可以使用的选项列表： 字段 类型 描述capped Boolean (可选)如果为true，则启用封闭的集合。上限集合是固定大小的集合，它在达到其最大大小时自动覆盖其最旧的条目。 如果指定true，则还需要指定size参数。autoIndexId Boolean (可选)如果为true，则在_id字段上自动创建索引。默认值为false。size 数字 (可选)指定上限集合的最大大小(以字节为单位)。 如果capped为true，那么还需要指定此字段的值。max 数字 (可选)指定上限集合中允许的最大文档数。由于option是可选，我们也可以不带配置项创建集合 123&gt; db.createCollection("mycollection")&gt; &gt; 删除集合db.collection.drop()用于从数据库中删除集合 123&gt; db.集合名.drop()&gt; &gt; 比如我们可以测试以下操作 12345&gt; db.createCollection("wscats")//创建名为wscats的集合&gt; show collections//显示该数据库所有集合 wscats&gt; db.wscats.drop()//删除名为wscats的集合&gt; &gt; 查看文档最简单查看文档的方法就是find()，会检索集合中所有的文档结果 123&gt; db.集合名.find()&gt; &gt; 要以格式化的方式显示结果，可以使用pretty()方法。 123&gt; db.集合名.find().pretty()&gt; &gt; 1.固值寻找寻找age集合里面所有含有属性值为wscats的文档结果，相当于where name = &#39;wscats&#39; 123&gt; db.age.find(&#123;name:"wscats"&#125;)&gt; &gt; 2.范值寻找操作 语法 示例 等效语句相等 {:} db.age.find({&quot;name&quot;:&quot;wscats&quot;}).pretty() where name = ‘wscats’小于 {:{$lt:}} db.age.find({&quot;likes&quot;:{$lt:50}}).pretty() where likes &lt; 50小于等于 {:{$lte:}} db.age.find({&quot;likes&quot;:{$lte:50}}).pretty() where likes &lt;= 50大于 {:{$gt:}} db.age.find({&quot;likes&quot;:{$gt:50}}).pretty() where likes &gt; 50大于等于 {:{$gte:}} db.age.find({&quot;likes&quot;:{$gte:50}}).pretty() where likes &gt;= 50不等于 {:{$ne:}} db.age.find({&quot;likes&quot;:{$ne:50}}).pretty() where likes != 50 3.AND和OR寻找AND在find()方法中，如果通过使用，将它们分开传递多个键，则mongodb将其视为AND条件。 以下是AND的基本语法 寻找_id为1并且name为wscats的所有结果集 123456789&gt; db.age.find(&gt; &#123;&gt; $and: [&gt; &#123;"_id": 1&#125;, &#123;"name": "wscats"&#125;&gt; ]&gt; &#125;&gt; )&gt; &gt; OR在要根据OR条件查询文档，需要使用$or关键字。以下是OR条件的基本语法 寻找name为corrine或者name为wscats的所有结果集 123456789&gt; db.age.find(&gt; &#123;&gt; $or: [&gt; &#123;"name": "corrine"&#125;, &#123;“name“: "wscats"&#125;&gt; ]&gt; &#125;&gt; )&gt; &gt; AND和OR等结合相当于语句where title = &quot;wscats&quot; OR ( title = &quot;corrine&quot; AND _id &lt; 5) 123456789101112131415&gt; db.age.find(&#123;&gt; $or: [&#123;&gt; "title": "wscats"&gt; &#125;, &#123;&gt; $and: [&#123;&gt; "title": "corrine"&gt; &#125;, &#123;&gt; "_id": &#123;&gt; $lte: 5&gt; &#125;&gt; &#125;]&gt; &#125;]&gt; &#125;)&gt; &gt; 插入文档文档的数据结构和JSON基本一样。所有存储在集合中的数据都是BSON格式。BSON是一种类json的一种二进制形式的存储格式,简称Binary JSON。 要将数据插入到mongodb集合中，需要使用mongodb的insert()或save()方法。 123&gt; db.集合名.insert(document)&gt; &gt; 比如我们可以插入以下数据 1234567891011&gt; db.wscats.insert(&#123;&gt; _id: 100,&gt; title: 'MongoDB Tutorials', &gt; description: 'node_tutorials',&gt; by: 'Oaoafly',&gt; url: 'https://github.com/Wscats/node-tutorial',&gt; tags: ['wscat','MongoDB', 'database', 'NoSQL','node'],&gt; num: 100,&gt; &#125;)&gt; &gt; 也可以支持插入多个，注意传入的是数组形式 123456789&gt; db.wscats.insert([&#123;&gt; _id: 100,&gt; title: ‘Hello’&gt; &#125;,&#123;&gt; _id: 101,&gt; title: ‘World’&gt; &#125;])&gt; &gt; 在插入的文档中，如果不指定_id参数，那么mongodb会为此文档分配一个唯一的ObjectId要插入文档，也可以使用db.post.save(document)。如果不在文档中指定_id，那么save()方法将与insert()方法一样自动分配ID的值。如果指定_id，则将以save()方法的形式替换包含_id的文档的全部数据。 123456&gt; db.wscats.save(&#123;&gt; _id: 111,&gt; title: 'Oaoafly Wscats', &gt; &#125;)&gt; &gt; 更新文档1.update()方法寻找第一条title为wscats的值，并且更新值title为corrine和age为12 12345678910&gt; db.age.update(&#123;&gt; 'title': 'wscats'&gt; &#125;, &#123;&gt; $set: &#123;&gt; 'title': 'corrine',&gt; 'age': 12&gt; &#125;&gt; &#125;)&gt; &gt; 默认情况下，mongodb只会更新一个文档。要更新多个文档，需要将参数multi设置为true，还可以配合find方法里面的各种复杂条件判断来筛选结果，然后更新多个文档 寻找所有title为wscats的值，并且更新值title为corrine和age为12 123456789101112&gt; db.age.update(&#123;&gt; 'title': 'wscats'&gt; &#125;, &#123;&gt; $set: &#123;&gt; 'title': 'corrine',&gt; 'age': 12&gt; &#125;&gt; &#125;, &#123;&gt; multi: true&gt; &#125;)&gt; &gt; 2.save()方法将_id主键为3的文档，覆盖新的值，注意_id为必传 123456&gt; db.age.save(&#123;&gt; &apos;_id&apos;:3,&gt; &apos;title&apos;: &apos;wscats&apos;&gt; &#125;)&gt; &gt; 删除文档删除主键_id为3的文档，默认是删除多条 12345&gt; db.age.remove(&#123;&gt; '_id':3&gt; &#125;)&gt; &gt; 建议在执行remove()函数前先执行find()命令来判断执行的条件是否正确 如果你只想删除第一条找到的记录可以设置justOne为1，如下所示 123&gt; db.age.remove(&#123;...&#125;,1)&gt; &gt; 全部删除 123&gt; db.age.remove(&#123;&#125;)&gt; &gt; Limit与Skip方法Limit如果你需要在mongodb中读取指定数量的数据记录，可以使用mongodb的Limit方法，limit()方法接受一个数字参数，该参数指定从mongodb中读取的记录条数。 123&gt; db.age.find().limit(数量)&gt; &gt; Skip我们除了可以使用limit()方法来读取指定数量的数据外，还可以使用skip()方法来跳过指定数量的数据，skip方法同样接受一个数字参数作为跳过的记录条数。 1234&gt; db.age.find().limit(数量).skip(数量)&gt; //skip()方法默认值为0&gt; &gt; 所以我们在实现分页的时候就可以用limit来限制每页多少条数据(一般固定一个值)，用skip来决定显示第几页(一个有规律变动的值) 排序在mongodb中使用使用sort()方法对数据进行排序，sort()方法可以通过参数指定排序的字段，并使用1和-1来指定排序的方式，其中1为升序排列，而-1是用于降序排列。 1 升序排列-1 降序排列 12&gt; db.集合名.find().sort(&#123;键值(属性值):1&#125;)&gt; 把age集合表重新根据_id主键进行降序排列 1234&gt; db.age.find().sort(&#123;&gt; "_id": -1&gt; &#125;)&gt; Node.js连接安装mongodb的模块 12&gt; npm install mongodb&gt; 1.连接数据库1234567&gt; var MongoClient = require('mongodb').MongoClient;&gt; //结尾是选择数据库名&gt; var DB_CONN_STR = 'mongodb://localhost:27017/wscats';&gt; MongoClient.connect(DB_CONN_STR, function(err, db) &#123;&gt; console.log("连接成功！");&gt; &#125;);&gt; 2.查询数据注意查询回来的结果需要toArray来遍历处理 123456789101112131415&gt; var MongoClient = require('mongodb').MongoClient;&gt; var DB_CONN_STR = 'mongodb://localhost:27017/wscats';&gt; &gt; MongoClient.connect(DB_CONN_STR, function(err, db) &#123;&gt; console.log("连接成功！");&gt; //选中age集合，并用find方法把结果集拿回来进行处理&gt; db.collection("age").find(&#123;title: "cba"&#125;).toArray(function(err, result) &#123;&gt; if (err) &#123;&gt; console.log('Error:' + err);&gt; return;&gt; &#125;&gt; console.log(result);&gt; &#125;);&gt; &#125;);&gt; 经过测试，读取大于100条的时候会出现报错官网解释，可以尝试用forEach代替 123456&gt; db.collection('pokemon').find(&#123;&#125;)&gt; .forEach(function(item)&#123;&gt; console.log(item)&gt; &#125;)&gt; &gt; 查询ID查询自动生成的ObjectId 123456789&gt; var ObjectId = require('mongodb').ObjectId;&gt; let _id = ObjectId("5bcae50ed1f2c2f5e4e1a76a");&gt; db.collection('xxx').find(&#123;&gt; "_id": _id&gt; &#125;).forEach(function (item) &#123;&gt; console.log(item)&gt; &#125;)&gt; &gt; 3.插入数据insert函数第一个参数是需要插入的值(可以一个也可以多个)，第二个参数是接受一个回调函数，当值插入成功后回返回插入值得一些关键信息，比如_id 123456789101112131415161718192021&gt; var MongoClient = require('mongodb').MongoClient;&gt; var DB_CONN_STR = 'mongodb://localhost:27017/wscats';&gt; &gt; MongoClient.connect(DB_CONN_STR, function(err, db) &#123;&gt; console.log("连接成功！");&gt; const db = client.db("demo");&gt; db.collection("age").insert([&gt; &#123; &gt; title: "插入的值A"&gt; &#125;, &#123;&gt; title: "插入的值B"&gt; &#125;&gt; ], function(err, result) &#123;&gt; if (err) &#123;&gt; console.log('Error:' + err);&gt; return;&gt; &#125;&gt; console.log(result)&gt; &#125;)&gt; &#125;);&gt; 4.更新数据注意如果不加$set就是完全替换原来的那份(没有设置的属性值将会丢失)，加上$set则只是更新对应的属性值，其余不做改变 123456789101112131415161718192021&gt; var MongoClient = require('mongodb').MongoClient;&gt; var DB_CONN_STR = 'mongodb://localhost:27017/wscats';&gt; &gt; MongoClient.connect(DB_CONN_STR, function(err, db) &#123;&gt; console.log("连接成功！");&gt; db.collection("age").update(&#123;&gt; "_id": 1&gt; &#125;, &#123;&gt; $set: &#123;&gt; title: "你好，世界",&gt; skill: "js"&gt; &#125;&gt; &#125;, function(err, result) &#123;&gt; if (err) &#123;&gt; console.log('Error:' + err);&gt; return;&gt; &#125;&gt; //console.log(result);&gt; &#125;);&gt; &#125;);&gt; 5.删除数据123456789101112131415161718&gt; var MongoClient = require('mongodb').MongoClient;&gt; var DB_CONN_STR = 'mongodb://localhost:27017/wscats';&gt; &gt; MongoClient.connect(DB_CONN_STR, function(err, db) &#123;&gt; console.log("连接成功！");&gt; db.collection("age").remove(&#123;&gt; "_id": 1&gt; &#125;, function(err, result) &#123;&gt; if (err) &#123;&gt; console.log('Error:' + err);&gt; return;&gt; &#125;&gt; //console.log(result);&gt; //关闭数据库&gt; db.close();&gt; &#125;);&gt; &#125;);&gt; 6.关闭数据库123&gt; db.close();&gt; &gt; 封装自定义模块新建mongo.js写入以下代码，封装自定义模块，方便其他路由复用，注意assert是node自带的断言模块，用于测试代码 参考 官网API文档 Node.js的断言模块assert进行单元测试 123456789101112131415161718&gt; const MongoClient = require('mongodb').MongoClient;&gt; const assert = require('assert');&gt; const url = 'mongodb://localhost:27017';&gt; const dbName = 'shop';&gt; function query(callback) &#123;&gt; MongoClient.connect(url, function(err, client) &#123;&gt; assert.equal(null, err);&gt; console.log("Connected successfully to server");&gt; const db = client.db(dbName);&gt; callback(db);&gt; client.close();&gt; &#125;);&gt; &#125;&gt; module.exports = &#123;&gt; query&gt; &#125;&gt; &gt; 在路由文件中引入和使用 12345678910&gt; var mongo = require('./mongo.js')&gt; router.post('/addproduct', function(req, res, next) &#123;&gt; mongo.query(function(db) &#123;&gt; db.collection("product").insertMany([req.body], function(err, result) &#123;&gt; console.log("Inserted 1 document into the collection");&gt; res.send('respond with a resource');&gt; &#125;);&gt; &#125;)&gt; &#125;);&gt; mongoose 下载mongoose 12&gt; npm install mongoose --save&gt; 连接数据库 12345678910&gt; var mongoose = require('mongoose');&gt; mongoose.connect('mongodb://localhost:27017/1823');&gt; var db = mongoose.connection;// 获取连接对象进行监听&gt; db.on('error',(err)=&gt;&#123;&gt; console.log('连接错误')&gt; &#125;);&gt; db.on('open', function() &#123;&gt; console.log('连接ok')&gt; &#125;);&gt; 创建schema对象 123456&gt; var UserSchema = new mongoose.Schema(&#123;&gt; name: String,&gt; pass: String,&gt; test:String&gt; &#125;);&gt; 将schema转化为数据模型 12&gt; let user = mongoose.model('user', UserSchema); //参数1 是集合的名字 与数据模型关联的schema对象&gt; 通过数据模型执行查询操作 mongoose 可视化 Robo 3T Studio3t Socket 实时刷新(蜡烛图) 推送服务 socket.io12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;socket.io&lt;/title&gt; &lt;script src="socket.io.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;gp6 交流区&lt;/h1&gt; &lt;div id="content" name="name" style="overflow-y: scroll; width: 400px; height: 300px; border: solid 1px #000"&gt;&lt;/div&gt; &lt;br /&gt; &lt;div&gt; &lt;input type="text" id="msg" style="width: 200px;"&gt; &lt;/div&gt; &lt;button id="submit"&gt;提交&lt;/button&gt; &lt;script&gt; var socket = io.connect('http://10.9.164.98:8081'); const content = document.getElementById('content') document.querySelector('#submit') .addEventListener('click', function () &#123; var msg2 = msg.value socket.emit('receive', msg2) msg.value = '' content.innerHTML += msg2 + '&lt;br/&gt;' &#125;, false) socket.on('message', function(msg)&#123; content.innerHTML += msg + '&lt;br/&gt;' &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; server.js12345678910111213141516171819202122var express = require('express');var app = express();var server = require('http').Server(app);var io = require('socket.io')(server);app.use(express.static(__dirname + '/client'))io.on('connection', function (socket) &#123; setInterval(function () &#123; socket.emit('list', 'abc') &#125;, 1000) socket.broadcast.emit('list', 'test'); socket.on('backend', (msg) =&gt; &#123; console.log(msg); &#125;) socket.on('receive', (msg) =&gt; &#123; socket.broadcast.emit('message', msg); &#125;)&#125;);server.listen(8081, '10.9.164.98'); net模块serverCode 12345678910111213141516171819202122232425262728293031323334const net = require('net')const server = new net.createServer()let clients = &#123;&#125;let clientName = 0server.on('connection', (client) =&gt; &#123; client.name = ++clientName clients[client.name] = client client.on('data', (msg) =&gt; &#123; // console.log('客户端传来：' + msg); broadcast(client, msg.toString()) &#125;) client.on('error', (e) =&gt; &#123; console.log('client error' + e); client.end() &#125;) client.on('close', (data) =&gt; &#123; delete clients[client.name] console.log(client.name + ' 下线了'); &#125;)&#125;)function broadcast(client, msg) &#123; for (var key in clients) &#123; clients[key].write(client.name + ' 说：' + msg) &#125;&#125;server.listen(9000) clientCode123456789101112131415161718192021222324252627282930313233343536373839404142var net = require('net')const readline = require('readline')var port = 9000var host = '127.0.0.1'var socket = new net.Socket()socket.setEncoding = 'UTF-8'socket.connect(port, host, () =&gt; &#123; socket.write('hello.')&#125;)socket.on('data', (msg) =&gt; &#123; console.log(msg.toString()) say()&#125;)socket.on('error', function (err) &#123; console.log('error' + err);&#125;)socket.on('close', function () &#123; console.log('connection closeed');&#125;)const r1 = readline.createInterface(&#123; input: process.stdin, output: process.stdout&#125;)function say() &#123; r1.question('请输入：', (inputMsg) =&gt; &#123; if (inputMsg != 'bye') &#123; socket.write(inputMsg + '\n') &#125; else &#123; socket.destroy() r1.close() &#125; &#125;)&#125; websocket12345678910111213141516171819const ws = new WebSocket('ws://localhost:8080/')ws.onopen = () =&gt; &#123; ws.send('大家好')&#125;ws.onmessage = (msg) =&gt; &#123; const content = document.getElementById('content') content.innerHTML += msg.data + '&lt;br/&gt;'&#125;ws.onerror = (err) =&gt; &#123; console.log(err);&#125;ws.onclose = () =&gt; &#123; console.log('closed~');&#125;ws.send(msg2) server.js12345678910111213141516171819202122232425const WebSocket = require('ws')const ws = new WebSocket.Server(&#123; port: 8080 &#125;)let clients = &#123;&#125;let clientName = 0ws.on('connection', (client) =&gt; &#123; client.name = ++clientName clients[client.name] = client client.on('message', (msg) =&gt; &#123; broadcast(client, msg) &#125;) client.on('close', () =&gt; &#123; delete clients[client.name] console.log(client.name + ' 离开了~') &#125;)&#125;)function broadcast(client, msg) &#123; for (var key in clients) &#123; clients[key].send(client.name + ' 说：' + msg) &#125;&#125; SSR 与 SEOvue 和 react 介绍 项目实战api接口 RestfulApi 规范 接口文档的生成(apidoc) 接口请求方式区别 跨域解决 cors jsonp proxy Hui 基本使用身份验证 http 请求的无状态性 JWT 用户登录 服务器端产生一个token (加密字符串) 发送给前端 前端将token 进行保存 前端发起数据请求的时候携带token 服务端 验证token 是否合法 如果合法继续操作 不合法终止操作 token 的使用场景 无状态请求 保持用户的登录状态 第三方登录（token+auth2.0） 非对称加密 通过私钥产生token 通过公钥解密token1234567891011// 1.产生公钥和私钥// 产生私钥 openssl genrsa -out ./private_key.pem 1024 1024 代表私钥长度// 产生公钥 openssl rsa -in ./private_key.pem -pubout -out ./public_key.pem let private_key=fs.readFileSync(path.join(__dirname,'./private_key.pem')) let public_key=fs.readFileSync(path.join(__dirname,'./public_key.pem')) var token = jwt.sign(palyload, private_key,&#123; algorithm: 'RS256'&#125;); console.log(token) let token='eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IueUqOaIt2lkIiwiaWF0IjoxNTUxMTUyNzk1fQ.TI_xDBvObHGAH7EV40WWpQemm5nx077Gdjq-pzDx0NWN5YFd40S7XcLmgoDdYscLM7vMOP0c7z1l83JUixqk7IBjBCU-tMNo_G5_-LGkQjV3vDYq_3TkXTl42lgmFA-EBey7W6W1PgPfYlowyHAyp-07hXaMRevgVkXm2lPEFXo' var decoded = jwt.verify(token, public_key); 1234567891011121314151617181920const jwt=require('jsonwebtoken')const scrict='sdjfksdjflajflasjflasjflksf'function creatToken(palyload)&#123; // 产生token palyload.ctime=Date.now() return jwt.sign(palyload,scrict)&#125;function checkToken(token)&#123; return new Promise((resovle,reject)=&gt;&#123; jwt.verify(token,scrict,(err,data)=&gt;&#123; if(err)&#123; reject('token 验证失败')&#125; resovle(data) &#125;) &#125;) &#125;module.exports=&#123; creatToken,checkToken&#125; Cookie+Session123456789const cookieParse=require('cookie-parser')const session = require('express-session')app.use(session(&#123; secret: 'hubwizApp', //为了安全性的考虑设置secret属性 cookie: &#123;maxAge: 60 * 1000 * 60 * 24 &#125;, //设置过期时间 resave: true, // 即使 session 没有被修改，也保存 session 值，默认为 true saveUninitialized: false, //无论有没有session cookie，每次请求都设置个session cookie ，默认给个标示为 connect.sid&#125;)); 登录成功 12req.session.sign = true;req.session.name = us; 需要验证的接口判断是否存在 注销session 1234app.get('/out', function(req, res)&#123; req.session.destroy(); res.redirect('/');&#125;) 图片上传 安装multer模块 1npm install multer 引用模块它是依赖于express的一个模块 1234//引用express并配置var express = require("express");var app = express();app.listen(3000); 123456var multer = require('multer');/*var upload = multer(&#123; //如果用这种方法上传，要手动添加文明名后缀 //如果用下面配置的代码，则可以省略这一句 dest: 'uploads/'&#125;)*/ 配置设置保存文件的地方，并根据上传的文件名对应文件添加后缀可以通过filename属性定制文件保存的格式 属性值 用途 destination 设置资源的保存路径。注意，如果没有这个配置项，默认会保存在/tmp/uploads下。此外，路径需要自己创建 filename 设置资源保存在本地的文件名 12345678910111213141516var storage = multer.diskStorage(&#123; //设置上传后文件路径，uploads文件夹会自动创建。 destination: function(req, file, cb) &#123; cb(null, './uploads') &#125;, //给上传文件重命名，获取添加后缀名 filename: function(req, file, cb) &#123; var fileFormat = (file.originalname).split("."); //给图片加上时间戳格式防止重名名 //比如把 abc.jpg图片切割为数组[abc,jpg],然后用数组长度-1来获取后缀名 cb(null, file.fieldname + '-' + Date.now() + "." + fileFormat[fileFormat.length - 1]); &#125;&#125;);var upload = multer(&#123; storage: storage&#125;); 接受文件upload.single(&#39;xxx&#39;)，xxx与表单中的name属性的值对应这里虽然用到post请求，但实际上不需要bodyParser模块处理 1234567891011app.post('/upload-single', upload.single('logo'), function(req, res, next) &#123; console.log(req.file) console.log('文件类型：%s', req.file.mimetype); console.log('原始文件名：%s', req.file.originalname); console.log((req.file.originalname).split(".")) console.log('文件大小：%s', req.file.size); console.log('文件保存路径：%s', req.file.path); res.send(&#123; ret_code: '0' &#125;);&#125;); 多图上传多图上传只要更改一下地方，前端往file输入框加多一个multiple=&quot;multiple&quot;属性值，此时就可以在选图的时候多选了，当然也可以并列多个file输入框(不推荐多个上传图片输入框)，这样体验会不好 1&lt;input type="file" name="logo" multiple="multiple" /&gt; 后端也需要相应的改变 123app.post('/upload-single', upload.single('logo'), function(req, res, next) &#123;//upload.single('logo')变为upload.array('logo', 2)，数字代表可以接受多少张图片app.post('/upload-single', upload.array('logo', 2), function(req, res, next) &#123; 如果不想有图片数量上传限制，我们可以用upload.any()方法 123456app.post('/upload-single', upload.any(), function(req, res, next) &#123; res.append("Access-Control-Allow-Origin","*"); res.send(&#123; wscats_code: '0' &#125;);&#125;); 前端部分 formData表单提交 12345&lt;form action="http://localhost:3000/upload-single" method="post" enctype="multipart/form-data"&gt; &lt;h2&gt;单图上传&lt;/h2&gt; &lt;input type="file" name="logo"&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt; formData表单+ajax提交 12345&lt;form id="uploadForm"&gt; &lt;p&gt;指定文件名： &lt;input type="text" name="filename" value="" /&gt;&lt;/p&gt; &lt;p&gt;上传文件： &lt;input type="file" name="logo" /&gt;&lt;/ p&gt; &lt;input type="button" value="上传" onclick="doUpload()" /&gt;&lt;/form&gt; FormData对象，是可以使用一系列的键值对来模拟一个完整的表单，然后使用XMLHttpRequest发送这个”表单” 注意点 processData设置为false。因为data值是FormData对象，不需要对数据做处理。 &lt;form&gt;标签添加enctype=&quot;multipart/form-data&quot;属性。 cache设置为false，上传文件不需要缓存。 contentType设置为false。因为是由&lt;form&gt;表单构造的FormData对象，且已经声明了属性enctype=&quot;multipart/form-data&quot;，所以这里设置为false 上传后，服务器端代码需要使用从查询参数名为logo获取文件输入流对象，因为&lt;input&gt;中声明的是name=&quot;logo&quot; 12345678910111213function doUpload() &#123; $.ajax(&#123; url: 'http://localhost:3000/upload-single', type: 'POST', cache: false, //不必须 data: new FormData($('#uploadForm')[0]), processData: false,//必须 contentType: false,//必须 success: function(data) &#123; console.log(data) &#125; &#125;)&#125; 参考文档Github MyDemoGithub MulterMDN FormData对象的使用 自动化测试 mochaMocha(‘摩卡’)，诞生于2011年，现在比较流行的JavaSscript测试框架之一,可以运行于Node环境和浏览器环境 测试框架:可以运行测试的工具。通过他，可以为JavaScript应用 添加测试,从而保证代码质量 参考文档mochajsmocha中文文档 安装配置使用npm 全局安装 1$ npm install --global mocha 项目依赖 局部安装 1$ npm isntall mocha 基本语法assert 断言 断言库：chai should 风格断言 expect 风格断言 全局安装chai 1npm install chai -g 案例使用递归执行 1$ mocha test --recursive]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo next主题设置]]></title>
    <url>%2F2019%2F06%2F21%2FHexo-next%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[next 配置详解 参考网页 http://theme-next.iissnan.com/ 里面有详细的配置方法 next 设置背景图片 找到 \themes\next\source\css_custom\custom.styl 文件在文件中添加代码 1234567891011121314@media screen and (min-width:1200px) &#123; body &#123; background-image:url(/images/background.jpg); background-repeat: no-repeat; background-attachment:fixed; background-position:50% 50%; background-size:cover &#125; #footer a &#123; color:#eee; &#125;&#125; 背景图片存放在主题文件 \source\images 下 next 设置背景动画 Canvas_nest （ 粒子特效 ） 在 next 文件下打开 Git 执行代码 1$ git clone https://github.com/theme-next/theme-next-canvas-nest source/lib/canvas-nest 进入 next 根目录下的 _config.yml（ 主题配置文件 ）下修改 canvas_nest: true(注意: 冒号后面要空格) 123456789# Canvas-nest# Dependencies: https://github.com/theme-next/theme-next-canvas-nestcanvas_nest: enable: true onmobile: true # display on mobile or not color: "0,0,255" # RGB values, use ',' to separate opacity: "0.5" # the opacity of line: 0~1 zIndex: -1 # z-index property of the background count: 99 # the number of lines 各样式具体指代 1234color ：线条颜色, 默认: &apos;0,0,0&apos;；三个数字分别为(R,G,B)opacity: 线条透明度（0~1）, 默认: 0.5count: 线条的总数量, 默认: 150zIndex: 背景的z-index属性，css属性用于控制所在层的位置, 默认: -1 预览并部署到服务器 1234$ hexo clean$ hexo g$ hexo s $ hexo d next 自定义页面 CSS 属性 启动本地服务 httplocahost:4000 进入主页 F12启动控制台 右键想要改变的模块类名 进入 next 主题文件夹下的 /source/css/_custom 找到 custom.styl 文件，这个文件是next供我们自定义样式的。在里面添加 CSS 样式即改变页面 CSS 属性]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何用github及Hexo搭建个人博客]]></title>
    <url>%2F2019%2F06%2F21%2F%E5%A6%82%E4%BD%95%E7%94%A8github%E5%8F%8AHexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[面试技巧]]></title>
    <url>%2F2019%2F06%2F21%2F%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[今天就到这吧，你回去等通知吧？ 面试官是这样的，我今天来到这里很不容易，路途也挺遥远的，我知道我可能不太符合岗位的要求。 我想知道我刚才说的问题哪里有不对的地方，知识点哪里有不对的地方。 我想向您请教一下，如果今天能跟您学习，也是我的幸运， 我虽然可能拿不到 Offer ，我也觉得今天的面试没有浪费时间，而且还向您学到了知识。 你愿意和什么样的领导共事？ 我希望我的领导在日常生活中对我的工作能有一些指导。 当我工作遇到问题的时候。能够及时的提醒我（ 少对领导提要求，多看看自己 ） 你的职业规划是什么？ 我希望我能学到更多的技术 我希望在一到三年我能从初中级软件开发工程师向高级软件开发工程师 接下来一到二年内从高级软件开发工程师向架构师转变 争取向技术总监开始转变 离职原因 负面原因不能说的（薪资太低，人际关系复杂，太辛苦，工作环境差） 过于自满不能说（做一些重复性的工作，想要更大的发展平台，技术达到瓶颈） 模板：我在上一家公司得到了很大的提升，技术通过项目的历练完全可以独自开发，适应杭州公司的开发需求。（有亲戚朋友在这想来这面发展/喜欢杭州这里城市想在杭州长期发展） 你怎么看待加班？ 我认为在工作中应该保持工作效率，如果任务安排合理的话，我认为不太需要加班。 但是我想在工作中加班是难免的，那么我会调配好自己的时间。高度配合。 为什么选择开发 我很喜欢软件开发这个行业，特别是软件开发这个行业是高质地和知识密集型的产业。 在这个行业，无论是个人技术还是其他的职业素养，都要为适应这个行业的发展而不断地提高。 所以在工作中学习是一件持久的事情。干到最后拿到高薪是必然的。 在工作中总结，在总结中积累经验。同时我也很享受学习的过程。 最后希望把学到的知识贡献给公司和团队。这是我选择软件开发的理由。 你的期望薪资？ 具体数值，不要说区间 打压工资的时候，谈福利，房补 餐补 车补 先把offer拿下，作为后补 你能为公司带来什么？在众多的面试者为什么要录用你？ 我已经有了一年的工作经历（ 我有足够的项目经验 ） 进公司可以直接上手项目，直接给公司带来效益。 省去了公司培养新人的经费。 如果在今后的工作中，发现自己不适合这份工作你会怎么办？ 我已经有了一年的工作经历。 我很明确自己要走开发这条路，并且我自己非常喜欢做开发。 所以不会工作一段时间就有打算离开公司的情况。 如果我身边的同事有这种情况的话。我会告诉他。 如果你喜欢这个行业，就要不断地去学习。虚心向领导和同事学习业务知识和处事经验。 了解岗位的需求，减少差距。 自我介绍 姓名 年龄 毕业院校 工作经历及任职岗位 项目（深刻） 我希望我今天的面试是一个很好的开始，谢谢 你觉得学历重要还是能力重要 是不是名牌大学不重要，重要的是我有能力完成工作 我已经有了一年的工作经验，掌握的技能可以胜任公司的职位 而且我比名牌大学学生的动手能力要强 所以我更适合贵公司的岗位 优点和缺点 我会把一件完整的事情分成小部分逐步完成 另外，在工作与同事沟通中会感觉很融洽 并且会站在他人角度想问题 其他人的评价 作为程序猿，我的强迫症太过严重，太逻辑性，太条理性 除了本公司，你还应聘了什么公司 面试的都是web前端，不用说具体的名字 第一家面试就有了offer，因为适应杭州市场需求，我想找电商和金融类的公司 自己也想做一个慎重的选择]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[细数那些npm报过的错]]></title>
    <url>%2F2019%2F06%2F21%2F%E7%BB%86%E6%95%B0%E9%82%A3%E4%BA%9BNPM%E6%8A%A5%E8%BF%87%E7%9A%84%E9%94%99%2F</url>
    <content type="text"><![CDATA[npm WARN checkPermissions Missing write access to解决办法： 复制后面的路径到 node_modules 我的电脑 打开复制路径 把刚才 github 的显示错误的路径 node_modules后面的同名文件夹删除 hexo init安装错误报错：FATAL D:\hexo not empty, please run hexo init on an empty folder and then 文件夹不为空 建议删掉 hexo 重新建一个文件夹 再试 FATAL Port 4000 has been used. Try other port instead. FATAL Something’s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html 解决方法：端口被占用， 终止终端hexo -d 部署的时候报错 FATAL Something’s wrong Template render error: expected variable原因： ​ 当文章中出现 }} ，两个大括号时，解析会出问题。常见于公式中，需要转译 解决： 需要转译的内容 注意： 包含的范围不要太广，刚刚括住那个范围就好，千万括住整篇文章，会出现未知的错误。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 框架级请求]]></title>
    <url>%2F2019%2F06%2F21%2FVue%E6%A1%86%E6%9E%B6%E7%BA%A7%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[Vue 框架级请求 vue-resource（停止更新） vue-resource作者推荐使用axios vue-resource在用法上和axios 相似度90+ vue2.0使用的基本上都是fetch / axios vue-resource 是有 jsonp 的 vue-resource 如果在vue中使用，是挂载当前的实例（ 组件 ）的 $http 属性身上的 this.$http( options ) this.$htttp.get( ) this.$http.post( ) axios（第三方库） axios 是没有 jsonp 数据请求类型的 axios 是promise（ 异步 ） axios 会对请求的结果进行再一次封装（ 提高安全性 ） 案例： 123456&lt;div id="app"&gt; &lt;button @click = "getData"&gt; get - mock - json &lt;/button&gt; &lt;button @click = "get_be_data"&gt; get - backend online- api &lt;/button&gt; &lt;button @click = "get_myself_php_data"&gt; get - myself - php -api &lt;/button&gt; &lt;button @click = "postData"&gt; post &lt;/button&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960new Vue(&#123; el: '#app', methods: &#123; getData () &#123; //进行get请求 // axios.get() -- $.get() // axios.post() ---$.post() // axios(options) -- $.ajax(options) // var p = axios(&#123; // url: './data/data.json' // &#125;) // console.log( p ) Promise对象 axios(&#123; url: './data/data.json', method: 'get',//默认就是get请求 &#125;) .then( res =&gt; console.log( res )) .catch( error =&gt; conosle.log( error )) &#125;, postData () &#123; // 进行post请求 &#125;, get_myself_php_data () &#123; axios(&#123; url: 'http://localhost/get.php', params: &#123; a: 1, b: 2 &#125; &#125;) .then( res =&gt; console.log( res )) .catch( error =&gt; console.log( error )) &#125;, get_be_data () &#123; // 跨域请求线上数据 - 卖座网 axios(&#123; url: 'https://m.maizuo.com/gateway', headers: &#123; 'X-Client-Info': '&#123;"a":"3000","ch":"1002","v":"5.0.4","e":"154549400038873748996477"&#125;', 'X-Host': 'mall.film-ticket.film.list' &#125;, params: &#123; cityId: 330100, pageNum: 1, pageSize: 10, type: 1, k: 7675918 &#125; &#125;) .then( res =&gt; console.log( res )) .catch( error =&gt; console.log( error )) &#125; &#125;&#125;) fetch ( javascript 原生提供 ) fetch 要手动进行一次数据格式化，但是 axios 是内部惊醒了数据的格式化 fetch get 方法请求数据，参数要直接连接在 url 上 fetch 格式化数据 有三种处理方法 .json( ) 格式化 json 类型数据， 将 json 类型 string 转换成 json 对象 .text( ) 格式化文本 .blob( ) 格式化二进制数据 fetch 如果按照官网文档书写post请求， 有坑 ， 携带数据出现问题 fetch post处理 设置请求头 通过 new URLSearchPrams 来携带参数]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue框架级请求</tag>
      </tags>
  </entry>
</search>
